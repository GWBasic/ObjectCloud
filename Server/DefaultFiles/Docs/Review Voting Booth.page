<div>A Walthrough of the Voting Booth's Source Code</div><p><a href="about.page">About ObjectCloud</a></p><p>ObjectCloud's voting booth system is built on top of an embedded <a target="_blank" title="" href="http://www.sqlite.org/">SQlite</a> database. &nbsp;Each .vote file is a unique <a target="_blank" title="" href="http://www.sqlite.org/">SQlite</a>&nbsp;file. &nbsp;The voting system uses server-side Javascript to prevent a malicious user from "stuffing the box."</p>
<h1>Server-Side code: <a target="_blank" title="" href="../Classes/vote">/Classes/vote</a></h1>
<p>/Classes/vote contains all server-side code for a voting booth.&nbsp; It is applied to all <span style="text-decoration: line-through;">files</span>
objects that have a .vote extension.&nbsp; This section attempts to
highlight coding techniques, but doesn't cover the entire source code
file.<br>
</p>
<h2>Setting up the embedded database schema</h2>
<p>The first part of the Javascript checks the embedded database's
version.&nbsp; If it hasn't been set, it creates the schema.&nbsp; Calls to
base.PostQuery() must be called as the .vote file's owner, and must be
called in an elevated security context.&nbsp; Once the schema is created,
the version is assigned to 0.<br>
</p>
<pre style="margin-left: 40px;"><span class="Apple-style-span" style="white-space: pre-wrap; font-size: medium; ">elevate(function()</span><br></pre><pre style="margin-left: 40px;"><span class="Apple-style-span" style="font-family: Times; white-space: normal; font-size: medium; "><pre style="word-wrap: break-word; white-space: pre-wrap; ">{
   var version = <span class="Apple-style-span" style="background-color: rgb(255, 255, 0);">base.GetVersion_Sync({});</span>

   // Constructor
   if (null == version)
      <span class="Apple-style-span" style="background-color: rgb(255, 255, 0);">lockMe(function()
      {
         callAsOwner(function()</span>
         {
            // Need to double-check in case someone else built the DB...
            var version = base.GetVersion_Sync({});

            if (null == version)
            {
               <span class="Apple-style-span" style="background-color: rgb(255, 255, 0);">base.PostQuery_Sync({query:"create table Question (qId integer not null primary key AUTOINCREMENT, text not null)"});</span>
               base.PostQuery_Sync({query:"create table AuthenticatedVotes (qId not null, voterId not null, timestamp integer not null)"});
               base.PostQuery_Sync({query:"create table AnonymousVotes (qId not null, timestamp integer not null)"});
               base.PostQuery_Sync({query:"create table Options (theOptions not null)"});

               var defaultOptions =
               {
                  canChangeVote: false,
                  canSeeResultsWithoutVoting: false,
                  title: "",
                  question: ""
               };

               base.PostQuery_Sync({query:"insert into Options (theOptions) values (@theOptions)", "@theOptions": JSON.stringify(defaultOptions)});

               <span class="Apple-style-span" style="background-color: rgb(255, 255, 0);">base.SetVersion_Sync({version:0});
               version = 0;</span>
            }
         });
      });
});</pre></span></pre>
<p>When constructing the schema, the entire object is locked.&nbsp; The
version is checked inside and outside of the lock in case multiple
requests attempt to create the schema.<br>
</p>
<h2>Getting Poll Results</h2>
<p>SQL is used to count the results.&nbsp; In this case, when getting the results, we use a compound query that has 3 sub-queries:</p><p>From the getVotes() function:<br></p>
<pre style="margin-left: 40px;">elevate(function()<br>{<br>   <span class="Apple-style-span" style="white-space: pre-wrap; font-size: medium;">resultsFromDB = base.PostQuery_Sync(
        {
            query: "select qId from Question group by qId;" +
               "select distinct qId, count(qId) as numVotes from AuthenticatedVotes group by qId;" +
               "select distinct qId, count(qId) as numVotes from AnonymousVotes group by qId;"
        });</span></pre><pre style="margin-left: 40px;"><span class="Apple-style-span" style="white-space: pre-wrap; font-size: medium;"></span>});<br><br>var resultsToReturn =<br>{<br>   authenticated: aggregate(resultsFromDB<span style="background-color: rgb(255, 255, 51);">[0]</span>, resultsFromDB<span style="background-color: rgb(255, 255, 51);">[1]</span>),<br>   anonymous: aggregate(resultsFromDB<span style="background-color: rgb(255, 255, 51);">[0]</span>, resultsFromDB<span style="background-color: rgb(255, 255, 51);">[2]</span>)<br>};<br></pre>
<p>The contents of aggregate are shown for your convenience:</p>
<pre style="margin-left: 40px;">function aggregate(validQIds, results)<br>{<br>   var toReturn = {};<br><br>   for (var ctr = 0; ctr &lt; <span style="background-color: rgb(255, 255, 51);">validQIds.length</span>; ctr++)<br>      toReturn[validQIds[ctr].qId] = 0;<br><br>   for (var ctr = 0; ctr &lt; <span style="background-color: rgb(255, 255, 51);">results.length</span>; ctr++)<br>      if (null != toReturn[results[ctr].qId])<br>         <span style="background-color: rgb(255, 255, 51);">toReturn[results[ctr].qId] = results[ctr].numVotes</span>;<br><br>   return toReturn;<br>}<br></pre>
<p>base.PostQuery() always returns a compound array.&nbsp; For compound
queries, the most significant index corresponds with the specific
query; for single queries the most significant index is always 0.&nbsp; The
inner array is always an array of objects returned from the query.&nbsp;
When a query returns a scalar, the scalar is used instead of the inner
array.</p>
<h2>Getting the Current User's Vote</h2>
<p>A simpler query is to get the current user's vote:</p>
<pre style="margin-left: 40px;">getVote.webCallable = "GET";<br>getVote.minimumWebPermission = "Read";  // In case someone's permission changed!  What if someone closed voting by revoking Write?<br>getVote.webReturnConvention = "JavaScriptObject";<br>function getVote()<br>{<br>   var qId = null;<br><br>   if (userMetadata.name != "anonymous")<br>      elevate(function()<br>      {<br>         var votes = <span style="background-color: rgb(255, 255, 51);">base.PostQuery_Sync(
         {
            query: "select qId from AuthenticatedVotes where voterId = @voterId",
            "@voterId": userMetadata.id
         })</span><span style="background-color: rgb(0, 255, 51);">[0]</span>;<br><br>         if (votes.length &gt; 0)<br>            <span style="background-color: rgb(255, 255, 51);">qId = votes[0].qId</span>;<br>      });<br><br>   return qId;<br>}<br></pre>
<p>The above query still returns an outer array, thus votes is assigned
to the 0th element of base.PostQuery's results.&nbsp; Another interesting
difference is that this query uses symbolic arguments.&nbsp; SQlite replaces
@voterId with the value passed in to the second argument's array.&nbsp; This
technique avoids <a target="_blank" title="" href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>.</p><p>Note that the above function sets the webCallable, minimumWebPermission, and webReturnConvention values for the getVote function.&nbsp; These values are needed in order to expose the getVote function to the web.<br></p>
<h2>Storing Options</h2>
<p>The voting booth's options are stored as a serialized JSON object in
a table with one row.&nbsp; This keeps the schema simple, and allows for
simple addition of options without needing to update the schema.</p>
<pre style="margin-left: 40px;">setOptions.webCallable = "POST_application_x_www_form_urlencoded";<br>setOptions.minimumWebPermission = "Administer";<br>setOptions.parser_canChangeVote = "bool";<br>setOptions.parser_canSeeResultsWithoutVoting = "bool";<br>function setOptions(canChangeVote, canSeeResultsWithoutVoting, question, title)<br>{<br>   var options = getOptions();<br><br>   if (null != canChangeVote)<br>      options.canChangeVote = canChangeVote;<br><br>   if (null != canSeeResultsWithoutVoting)<br>      options.canSeeResultsWithoutVoting = canSeeResultsWithoutVoting;<br><br>   if (null != question)<br>      options.question = question;<br><br>   if (null != title)<br>      options.title = title;<br><br>   elevate(function()<br>   {<br>      base.PostQuery_Sync(
      {
         query: "update Options set theOptions=@theOptions",
         "@theOptions": JSON.stringify(options)
      });<br>   });<br>}<br><br></pre>
<pre style="margin-left: 40px;">function getOptions()<br>{<br>   var options;<br>   elevate(function()<br>   {<br>      callAsOwner(function()<br>      {<br>         options = base.PostQuery_Sync(
         {
            query: "select theOptions from Options"
         })<span class="Apple-style-span" style="background-color: rgb(255, 255, 0);">[0][0]</span>;<br>         options = eval('(' + options + ')');<br>      });<br>   });<br><br>   return options;<br>}<br></pre>
<p>Because PostQuery always returns a compound array, the single row
from the Options table is element [0][0].&nbsp; theOptions, a serialized
JSON string, is eval()ed to parse.&nbsp; Because the string comes from
trusted sources, we can use eval() instead of JSON.parse().</p>
<h1>The Template .vote File, <a target="_blank" title="" href="../Templates/Voting%20Booth%20Template.vote">/Templates/Voting Booth Template.vote</a><br>
</h1>
<p>The template .vote file, <a target="_blank" title="" href="../Templates/Voting%20Booth%20Template.vote">/Templates/Voting Booth Template.vote</a> is copied whenever a new voting booth is created.&nbsp; The file was created with the following steps:</p>
<ol><li>In <a target="_blank" title="" href="../Templates">/Templates</a>, a new file was created of type "Database."&nbsp; The name was "Voting Booth Template.vote"</li><li>The new file was viewed to stimulate creating its schema</li></ol>
<p>The following line was added to <a target="_blank" title="" href="../Shell/Navigation/Directory.json">/Shell/Navigation/Directory.json</a> so that users can create a new Voting Booth:</p>
<pre style="margin-left: 40px;">{"Template":"/Templates/Voting Booth Template.vote","Extension":".vote","Display":"Voting Booth (Experimental)"}<br></pre>

<h1>Viewing a .vote file with SQL</h1>
<p>It's possible to use Whisquil, a simple SQL shell, to view the
contents of a .vote file.&nbsp; To do so, use the following URL syntax:</p>
<pre style="margin-left: 40px;">/Shell/Editors/Whisquil.wchtml?FileName=[Path to .vote file]<br></pre>
<h1>Narl, the .vote Editor</h1>
<p>Narl, (pronounced "nar-eye",) allows someone to set the valid responses and options for a voting booth.&nbsp; Narl is stored at <a target="_blank" title="" href="../Shell/Editors/Narl.wchtml?Method=ReadAll">/Shell/Editors/Narl.wchtml</a><br>
</p>
<p>Narl loads the Javascript object to access the server-side code with the following &lt;? Scripts... tag:</p>
<pre style="margin-left: 40px;">&lt;? Scripts(/API/Prototype.js, <span style="background-color: rgb(255, 255, 51);">&lt;? $_GET["FileName"] ?&gt;?Method=GetJSW&amp;assignToVariable=VotingBooth,<span style="background-color: rgb(255, 255, 255);"> /API/nicEdit.js) ?&gt;</span></span><br></pre>
<p>The options and questions are pre-loaded using WebComponents:</p>
<pre style="margin-left: 40px;">var pollInfo = <span style="background-color: rgb(255, 255, 51);">&lt;? WebComponent($_GET["FileName"] . "?Method=getQuestionsAndOptions") ?&gt;;</span><br>var options = pollInfo.options;<br>var questions = pollInfo.questions;<br></pre>
<p>Options are written back to the server using the VotingBooth object
that wraps all AJAX.&nbsp; (Note:&nbsp; Prototype.js gives the $("...") syntax)<br>
</p>
<pre style="margin-left: 40px;">function updateOptions()<br>{<br>   $("OptionsEditor").disable();<br><br>   var question = $("question").innerHTML;<br><br>   VotingBooth.setOptions(<br>   {
      canChangeVote: $("canChangeVote").checked,
      canSeeResultsWithoutVoting: $("canSeeResultsWithoutVoting").checked,
      question: question,
      title: $("q_title").value,
   },
   function()
   {
      $("OptionsEditor").enable();
      options.question = question;
   });
}<br></pre>
<p>A question is added and updated using the VotingBooth object as well:</p>
<pre style="margin-left: 40px;">function addQuestion()<br>{<br>   var newQuestion = $("AddQuestionInput").value;<br>   $("AddQuestionInput").value = "";<br><br>   VotingBooth.addQuestion(<br>      newQuestion,<br>      {},<br>      displayQuestion);<br>}<br><br>function updateQuestion(qId)<br>{<br>   var text = $("q" + qId).value;<br>   VotingBooth.updateQuestion(<br>      qId,<br>      text,<br>      {},<br>      function(question)<br>      {<br>         $("q" + qId).value = question.text;<br>      });<br>}<br></pre>
<h1>Goreal, the voting booth Program<br>
</h1>
<p>Goreal, (pronounced "Gore-al,") allows someone to vote.&nbsp; Goreal is stored at <a target="_blank" title="" href="../Shell/Viewers/Goreal.wchtml?Method=ReadAll">/Shell/Viewers/Goreal.wchtml</a><br>
</p>
<p>Goreal loads the Javascript wrapper, questions, and options just like Narl.</p>
<p>Goreal loads the currently-submitted vote with a WebComponent.&nbsp; If the user hasn't voted, it's set to null.</p>
<pre style="margin-left: 40px;">var vote = &lt;? WebComponent($_GET["FileName"] . "?Method=getVote") ?&gt;;<br></pre>
<p>The vote is submitted through AJAX:</p><pre style="margin-left: 40px;">function submitVote()<br>{<br>   var voteToSubmit = null;<br><br>   questions.each(function(question)<br>   {<br>      if ($("q" + question.qId).checked)<br>         voteToSubmit = question.qId;<br>   });<br><br>   if (null != voteToSubmit)<br>      VotingBooth.vote(<br>         voteToSubmit,<br>         {},<br>         function()<br>         {<br>            window.location.reload(true);<br>         });<br>      else<br>         alert("Please select a question");<br>}<br></pre><p>Results are also loaded through AJAX.&nbsp; In the event that the query takes awhile to run, the user will still see a page:</p><pre style="margin-left: 40px;">if (options.canSeeResultsWithoutVoting || null != vote)<br>   VotingBooth.getVotes(<br>      {},<br>      function(votes)<br>      {<br>         questions.each(function(question)<br>         {<br>            var qId = question.qId;<br>            var qSpan = $("s" + qId);<br><br>            qSpan.innerHTML = ': &lt;span style="font-size: 1.5em"&gt;' + (votes.authenticated[qId] + votes.anonymous[qId]) + '&lt;/span&gt;&lt;span style="font-size: 0.75em"&gt; (' + <br>               votes.authenticated[qId] + ' authenticated, ' + votes.anonymous[qId] + ' anonymous)&lt;/span&gt;';<br>         });<br>      });<br></pre><p><a href="about.page">About ObjectCloud</a></p><p></p>