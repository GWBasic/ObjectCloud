{"Title":"A Walthrough of the Voting Booth's Source Code","Contents":"<p><a href=\"about.page\">About ObjectCloud</a></p><p>ObjectCloud's voting booth system is built on top of an embedded <a target=\"_blank\" title=\"\" href=\"http://www.sqlite.org/\">SQlite</a> database. &#160;Each .vote file is a unique <a target=\"_blank\" title=\"\" href=\"http://www.sqlite.org/\">SQlite</a>&#160;file. &#160;The voting system uses server-side Javascript to prevent a malicious user from \"stuffing the box.\"</p>\n<h1>Server-Side code: <a target=\"_blank\" title=\"\" href=\"../Classes/vote\">/Classes/vote</a></h1>\n<p>/Classes/vote contains all server-side code for a voting booth.&#160; It is applied to all <span style=\"text-decoration: line-through;\">files</span>\nobjects that have a .vote extension.&#160; This section attempts to\nhighlight coding techniques, but doesn't cover the entire source code\nfile.<br/>\n</p>\n<h2>Setting up the embedded database schema</h2>\n<p>The first part of the Javascript checks the embedded database's\nversion.&#160; If it hasn't been set, it creates the schema.&#160; Calls to\nbase.PostQuery() must be called as the .vote file's owner, and must be\ncalled in an elevated security context.&#160; Once the schema is created,\nthe version is assigned to 0.<br/>\n</p>\n<pre style=\"margin-left: 40px;\"><span class=\"Apple-style-span\" style=\"white-space: pre-wrap; font-size: medium; \">elevate(function()</span><br/></pre><pre style=\"margin-left: 40px;\"><span class=\"Apple-style-span\" style=\"font-family: Times; white-space: normal; font-size: medium; \"></span><pre style=\"word-wrap: break-word; white-space: pre-wrap; \">{\n   var version = <span class=\"Apple-style-span\" style=\"background-color: rgb(255, 255, 0);\">base.GetVersion_Sync({});</span>\n\n   // Constructor\n   if (null == version)\n      <span class=\"Apple-style-span\" style=\"background-color: rgb(255, 255, 0);\">lockMe(function()\n      {\n         callAsOwner(function()</span>\n         {\n            // Need to double-check in case someone else built the DB...\n            var version = base.GetVersion_Sync({});\n\n            if (null == version)\n            {\n               <span class=\"Apple-style-span\" style=\"background-color: rgb(255, 255, 0);\">base.PostQuery_Sync({query:\"create table Question (qId integer not null primary key AUTOINCREMENT, text not null)\"});</span>\n               base.PostQuery_Sync({query:\"create table AuthenticatedVotes (qId not null, voterId not null, timestamp integer not null)\"});\n               base.PostQuery_Sync({query:\"create table AnonymousVotes (qId not null, timestamp integer not null)\"});\n               base.PostQuery_Sync({query:\"create table Options (theOptions not null)\"});\n\n               var defaultOptions =\n               {\n                  canChangeVote: false,\n                  canSeeResultsWithoutVoting: false,\n                  title: \"\",\n                  question: \"\"\n               };\n\n               base.PostQuery_Sync({query:\"insert into Options (theOptions) values (@theOptions)\", \"@theOptions\": JSON.stringify(defaultOptions)});\n\n               <span class=\"Apple-style-span\" style=\"background-color: rgb(255, 255, 0);\">base.SetVersion_Sync({version:0});\n               version = 0;</span>\n            }\n         });\n      });\n});</pre></pre>\n<p>When constructing the schema, the entire object is locked.&#160; The\nversion is checked inside and outside of the lock in case multiple\nrequests attempt to create the schema.<br/>\n</p>\n<h2>Getting Poll Results</h2>\n<p>SQL is used to count the results.&#160; In this case, when getting the results, we use a compound query that has 3 sub-queries:</p><p>From the getVotes() function:<br/></p>\n<pre style=\"margin-left: 40px;\">elevate(function()<br/>{<br/>   <span class=\"Apple-style-span\" style=\"white-space: pre-wrap; font-size: medium;\">resultsFromDB = base.PostQuery_Sync(\n        {\n            query: \"select qId from Question group by qId;\" +\n               \"select distinct qId, count(qId) as numVotes from AuthenticatedVotes group by qId;\" +\n               \"select distinct qId, count(qId) as numVotes from AnonymousVotes group by qId;\"\n        });</span></pre><pre style=\"margin-left: 40px;\"><span class=\"Apple-style-span\" style=\"white-space: pre-wrap; font-size: medium;\"></span>});<br/><br/>var resultsToReturn =<br/>{<br/>   authenticated: aggregate(resultsFromDB<span style=\"background-color: rgb(255, 255, 51);\">[0]</span>, resultsFromDB<span style=\"background-color: rgb(255, 255, 51);\">[1]</span>),<br/>   anonymous: aggregate(resultsFromDB<span style=\"background-color: rgb(255, 255, 51);\">[0]</span>, resultsFromDB<span style=\"background-color: rgb(255, 255, 51);\">[2]</span>)<br/>};<br/></pre>\n<p>The contents of aggregate are shown for your convenience:</p>\n<pre style=\"margin-left: 40px;\">function aggregate(validQIds, results)<br/>{<br/>   var toReturn = {};<br/><br/>   for (var ctr = 0; ctr &lt; <span style=\"background-color: rgb(255, 255, 51);\">validQIds.length</span>; ctr++)<br/>      toReturn[validQIds[ctr].qId] = 0;<br/><br/>   for (var ctr = 0; ctr &lt; <span style=\"background-color: rgb(255, 255, 51);\">results.length</span>; ctr++)<br/>      if (null != toReturn[results[ctr].qId])<br/>         <span style=\"background-color: rgb(255, 255, 51);\">toReturn[results[ctr].qId] = results[ctr].numVotes</span>;<br/><br/>   return toReturn;<br/>}<br/></pre>\n<p>base.PostQuery() always returns a compound array.&#160; For compound\nqueries, the most significant index corresponds with the specific\nquery; for single queries the most significant index is always 0.&#160; The\ninner array is always an array of objects returned from the query.&#160;\nWhen a query returns a scalar, the scalar is used instead of the inner\narray.</p>\n<h2>Getting the Current User's Vote</h2>\n<p>A simpler query is to get the current user's vote:</p>\n<pre style=\"margin-left: 40px;\">getVote.webCallable = \"GET\";<br/>getVote.minimumWebPermission = \"Read\";  // In case someone's permission changed!  What if someone closed voting by revoking Write?<br/>getVote.webReturnConvention = \"JavaScriptObject\";<br/>function getVote()<br/>{<br/><span class=\"Apple-style-span\" style=\"font-family: Times; white-space: normal; font-size: medium; \"></span><pre style=\"word-wrap: break-word; white-space: pre-wrap; \">   var userMetadata = getConnectionMetadata();\n</pre>   var qId = null;<br/><br/>   if (userMetadata.name != \"anonymous\")<br/>      elevate(function()<br/>      {<br/>         var votes = <span style=\"background-color: rgb(255, 255, 51);\">base.PostQuery_Sync(\n         {\n            query: \"select qId from AuthenticatedVotes where voterId = @voterId\",\n            \"@voterId\": userMetadata.id\n         })</span><span style=\"background-color: rgb(0, 255, 51);\">[0]</span>;<br/><br/>         if (votes.length &gt; 0)<br/>            <span style=\"background-color: rgb(255, 255, 51);\">qId = votes[0].qId</span>;<br/>      });<br/><br/>   return qId;<br/>}<br/></pre>\n<p>The above query still returns an outer array, thus votes is assigned\nto the 0th element of base.PostQuery's results.&#160; Another interesting\ndifference is that this query uses symbolic arguments.&#160; SQlite replaces\n@voterId with the value passed in to the second argument's array.&#160; This\ntechnique avoids <a target=\"_blank\" title=\"\" href=\"http://en.wikipedia.org/wiki/SQL_injection\">SQL injection attacks</a>.</p><p>Note that the above function sets the webCallable, minimumWebPermission, and webReturnConvention values for the getVote function.&#160; These values are needed in order to expose the getVote function to the web.<br/></p>\n<h2>Storing Options</h2>\n<p>The voting booth's options are stored as a serialized JSON object in\na table with one row.&#160; This keeps the schema simple, and allows for\nsimple addition of options without needing to update the schema.</p>\n<pre style=\"margin-left: 40px;\">setOptions.webCallable = \"POST_application_x_www_form_urlencoded\";<br/>setOptions.minimumWebPermission = \"Administer\";<br/>setOptions.parser_canChangeVote = \"bool\";<br/>setOptions.parser_canSeeResultsWithoutVoting = \"bool\";<br/>function setOptions(canChangeVote, canSeeResultsWithoutVoting, question, title)<br/>{<br/>   var options = getOptions();<br/><br/>   if (null != canChangeVote)<br/>      options.canChangeVote = canChangeVote;<br/><br/>   if (null != canSeeResultsWithoutVoting)<br/>      options.canSeeResultsWithoutVoting = canSeeResultsWithoutVoting;<br/><br/>   if (null != question)<br/>      options.question = question;<br/><br/>   if (null != title)<br/>      options.title = title;<br/><br/>   elevate(function()<br/>   {<br/>      base.PostQuery_Sync(\n      {\n         query: \"update Options set theOptions=@theOptions\",\n         \"@theOptions\": JSON.stringify(options)\n      });<br/>   });<br/>}<br/><br/></pre>\n<pre style=\"margin-left: 40px;\">function getOptions()<br/>{<br/>   var options;<br/>   elevate(function()<br/>   {<br/>      callAsOwner(function()<br/>      {<br/>         options = base.PostQuery_Sync(\n         {\n            query: \"select theOptions from Options\"\n         })<span class=\"Apple-style-span\" style=\"background-color: rgb(255, 255, 0);\">[0][0]</span>;<br/>         options = eval('(' + options + ')');<br/>      });<br/>   });<br/><br/>   return options;<br/>}<br/></pre>\n<p>Because PostQuery always returns a compound array, the single row\nfrom the Options table is element [0][0].&#160; theOptions, a serialized\nJSON string, is eval()ed to parse.&#160; Because the string comes from\ntrusted sources, we can use eval() instead of JSON.parse().</p>\n<h1>The Template .vote File, <a target=\"_blank\" title=\"\" href=\"../Templates/Voting%20Booth%20Template.vote\">/Templates/Voting Booth Template.vote</a><br/>\n</h1>\n<p>The template .vote file, <a target=\"_blank\" title=\"\" href=\"../Templates/Voting%20Booth%20Template.vote\">/Templates/Voting Booth Template.vote</a> is copied whenever a new voting booth is created.&#160; The file was created with the following steps:</p>\n<ol><li>In <a target=\"_blank\" title=\"\" href=\"../Templates\">/Templates</a>, a new file was created of type \"Database.\"&#160; The name was \"Voting Booth Template.vote\"</li><li>The new file was viewed to stimulate creating its schema</li></ol>\n<p>The following line was added to <a target=\"_blank\" title=\"\" href=\"../Shell/Navigation/Directory.json\">/Shell/Navigation/Directory.json</a> so that users can create a new Voting Booth:</p>\n<pre style=\"margin-left: 40px;\">{\"Template\":\"/Templates/Voting Booth Template.vote\",\"Extension\":\".vote\",\"Display\":\"Voting Booth (Experimental)\"}<br/></pre>\n\n<h1>Viewing a .vote file with SQL</h1>\n<p>It's possible to use Whisquil, a simple SQL shell, to view the\ncontents of a .vote file.&#160; To do so, use the following URL syntax:</p>\n<pre style=\"margin-left: 40px;\">/Shell/Editors/Whisquil.wchtml?FileName=[Path to .vote file]<br/></pre>\n<h1>Narl, the .vote Editor</h1>\n<p>Narl, (pronounced \"nar-eye\",) allows someone to set the valid responses and options for a voting booth.&#160; Narl is stored at <a target=\"_blank\" title=\"\" href=\"../Shell/Editors/Narl.wchtml?Method=ReadAll\">/Shell/Editors/Narl.wchtml</a><br/>\n</p>\n<p>Narl loads the Javascript object to access the server-side code with the following &lt;? Scripts... tag:</p>\n<pre style=\"margin-left: 40px;\">&lt;? Scripts(/API/Prototype.js, <span style=\"background-color: rgb(255, 255, 51);\">&lt;? $_GET[\"FileName\"] ?&gt;?Method=GetJSW&amp;assignToVariable=VotingBooth,<span style=\"background-color: rgb(255, 255, 255);\"> /API/nicEdit.js) ?&gt;</span></span><br/></pre>\n<p>The options and questions are pre-loaded using WebComponents:</p>\n<pre style=\"margin-left: 40px;\">var pollInfo = <span style=\"background-color: rgb(255, 255, 51);\">&lt;? WebComponent($_GET[\"FileName\"] . \"?Method=getQuestionsAndOptions\") ?&gt;;</span><br/>var options = pollInfo.options;<br/>var questions = pollInfo.questions;<br/></pre>\n<p>Options are written back to the server using the VotingBooth object\nthat wraps all AJAX.&#160; (Note:&#160; Prototype.js gives the $(\"...\") syntax)<br/>\n</p>\n<pre style=\"margin-left: 40px;\">function updateOptions()<br/>{<br/>   $(\"OptionsEditor\").disable();<br/><br/>   var question = $(\"question\").innerHTML;<br/><br/>   VotingBooth.setOptions(<br/>   {\n      canChangeVote: $(\"canChangeVote\").checked,\n      canSeeResultsWithoutVoting: $(\"canSeeResultsWithoutVoting\").checked,\n      question: question,\n      title: $(\"q_title\").value,\n   },\n   function()\n   {\n      $(\"OptionsEditor\").enable();\n      options.question = question;\n   });\n}<br/></pre>\n<p>A question is added and updated using the VotingBooth object as well:</p>\n<pre style=\"margin-left: 40px;\">function addQuestion()<br/>{<br/>   var newQuestion = $(\"AddQuestionInput\").value;<br/>   $(\"AddQuestionInput\").value = \"\";<br/><br/>   VotingBooth.addQuestion(<br/>      newQuestion,<br/>      {},<br/>      displayQuestion);<br/>}<br/><br/>function updateQuestion(qId)<br/>{<br/>   var text = $(\"q\" + qId).value;<br/>   VotingBooth.updateQuestion(<br/>      qId,<br/>      text,<br/>      {},<br/>      function(question)<br/>      {<br/>         $(\"q\" + qId).value = question.text;<br/>      });<br/>}<br/></pre>\n<h1>Goreal, the voting booth Program<br/>\n</h1>\n<p>Goreal, (pronounced \"Gore-al,\") allows someone to vote.&#160; Goreal is stored at <a target=\"_blank\" title=\"\" href=\"../Shell/Viewers/Goreal.wchtml?Method=ReadAll\">/Shell/Viewers/Goreal.wchtml</a><br/>\n</p>\n<p>Goreal loads the Javascript wrapper, questions, and options just like Narl.</p>\n<p>Goreal loads the currently-submitted vote with a WebComponent.&#160; If the user hasn't voted, it's set to null.</p>\n<pre style=\"margin-left: 40px;\">var vote = &lt;? WebComponent($_GET[\"FileName\"] . \"?Method=getVote\") ?&gt;;<br/></pre>\n<p>The vote is submitted through AJAX:</p><pre style=\"margin-left: 40px;\">function submitVote()<br/>{<br/>   var voteToSubmit = null;<br/><br/>   questions.each(function(question)<br/>   {<br/>      if ($(\"q\" + question.qId).checked)<br/>         voteToSubmit = question.qId;<br/>   });<br/><br/>   if (null != voteToSubmit)<br/>      VotingBooth.vote(<br/>         voteToSubmit,<br/>         {},<br/>         function()<br/>         {<br/>            window.location.reload(true);<br/>         });<br/>      else<br/>         alert(\"Please select a question\");<br/>}<br/></pre><p>Results are also loaded through AJAX.&#160; In the event that the query takes awhile to run, the user will still see a page:</p><pre style=\"margin-left: 40px;\">if (options.canSeeResultsWithoutVoting || null != vote)<br/>   VotingBooth.getVotes(<br/>      {},<br/>      function(votes)<br/>      {<br/>         questions.each(function(question)<br/>         {<br/>            var qId = question.qId;<br/>            var qSpan = $(\"s\" + qId);<br/><br/>            qSpan.innerHTML = ': &lt;span style=\"font-size: 1.5em\"&gt;' + (votes.authenticated[qId] + votes.anonymous[qId]) + '&lt;/span&gt;&lt;span style=\"font-size: 0.75em\"&gt; (' + <br/>               votes.authenticated[qId] + ' authenticated, ' + votes.anonymous[qId] + ' anonymous)&lt;/span&gt;';<br/>         });<br/>      });<br/></pre><p><a href=\"about.page\">About ObjectCloud</a></p><p></p>"}