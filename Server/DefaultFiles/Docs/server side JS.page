<div>Secure Storage with Server-Side Javascript</div><p><a href="about.page">About ObjectCloud</a></p><p>A limitation of the data persistence techniques shown in <a target="" title="" href="simple%20storage%20walkthrough.page">Simple storage</a> is that they have very limited security. &nbsp;The techniques might suffice when only a small number of trusted people have write access, but what if we want anyone on the internet to write information? &nbsp;If we allow everyone with an internet connection to modify a file in any way they see fit; they might make modifications that we don't want, or that could break our program! &nbsp;In these situations, we can enforce data validity by with server-side Javascript.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">ObjectCloud uses </span><a style="font-style: italic;" target="_blank" title="" href="http://www.mozilla.org/rhino/">Rhino</a><span style="font-style: italic;"> </span><a style="font-style: italic;" target="_blank" title="" href="http://www.codeproject.com/KB/cs/EmbeddingJSCS.aspx">translated into a CLR-compliant .dll file</a><span style="font-style: italic;">.</span><br></p><h1>Classes<br></h1><p>Server-Side Javascript borrows the "class" concept from Object-Oriented programming.&nbsp; All classes are stored in the <a target="_blank" title="" href="../Classes">/Classes</a> folder.&nbsp; Each class is a text file without an extension that contains Javascript.&nbsp; When creating a class, the server-side code applies to all files with the same extension as the class name.</p><p>For example, for a class named foo:</p><ul><li>The javascript would be stored in a text file in /Classes/foo</li><li><span style="text-decoration: line-through;">Files</span> Objects named "file.foo," "xyz.foo," and "blah.foo" would be handled by the Javascript in /Classes/foo.</li></ul><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">If a folder has a Classes sub-folder, the classes in the sub-folder override any classes in the </span><a style="font-style: italic;" target="_blank" title="" href="../Classes">/Classes</a><span style="font-style: italic;"> folder.</span></p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">All server-side Javascript files must be owned by a member of the administrators group.</span><br></p><h1>Encapsulation</h1><p>When a class is created, the <span style="text-decoration: line-through;">file's</span> object's underlying methods are no longer accessible to the web, and therefore, no longer callable through AJAX.&nbsp; Instead, the Javascript methods are made accessible to the web and AJAX.&nbsp; The server-side Javascript can, however, call the underlying methods when storing or retrieving data.&nbsp; Within server-side Javascript, the underlying <span style="text-decoration: line-through;">file's</span> object's methods are placed into the "base" object.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">Encapsulation was chosen as a technique to effectively block malicious parties from manipulating data in unexpected ways.&nbsp; Future versions of ObjectCloud may introduce techniques to automatically expose underlying methods to the web; although the default behavior will always be to hide these methods.&nbsp; Feedback on this decision is encouraged and appreciated.</span><br></p><h1>Persistence, Isolation, and Run-Time data<br></h1><p>All data must be persisted by calling the underlying base object.&nbsp; Data stored in runtime variables is not saved and will be discarded at some point in the future.&nbsp; Every user has their own copy of the runtime, so users can not share data.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">Feedback on these constraints is welcome, encouraged, and valued.</span><br></p><h1>Debugging</h1><p>Minimal debugging is supported.&nbsp; To debug, append ?Method=GetServersideJavascriptErrors when viewing a file of a given class.&nbsp; For example, to debug /Classes/foo, visit /MyFiles/myfoo.foo?Method=GetServersideJavascriptErrors</p><p>A rudimentary database program, Whisquil, is provided:&nbsp; <a target="_blank" title="" href="/Shell/Editors/Whisquil.wchtml?Method=ReadAll">/Shell/Editors/Whisquil.wchtml</a>.&nbsp; To view a database, visit /Shell/Editors/Whisquil.wchtml?FileName=[file name].&nbsp; For example, to view /MyFiles/myfoo.foo, visit /Shell/Editors/Whisquil.wchtml?FileName=/MyFiles/myfoo.foo.<br></p><h1>Security</h1><p>By default, when an object is wrapped by server-side JavaScript, its original web-accessible methods are hidden.&nbsp; This is to prevent security issues where server-side JavaScript is used to validate data prior to writing it.</p><p>To enable access to underlying web-accessible methods, the server-side JavaScript must set some options, as follows:</p><pre style="margin-left: 40px;">var options =<br>{<br>   BlockWebMethods: false<br>};<br></pre><p style="margin-left: 40px;"><span style="font-weight: bold;">Note:</span>&nbsp; <span style="font-style: italic;">Be careful when setting BlockWebMethods to false.&nbsp; If your server-side JavaScript needs to validate data prior to persisting it, then you could open a potential security hole!</span><br></p><h1>Exposing a Function to the Web</h1><p>By default, all functions in server-side Javascript are not exposed to the web.&nbsp; This is to prevent unanticipated behavior if malicious parties call functions that aren't intended for the web.&nbsp; How ObjectCloud exposes a Javascript function to the web is controlled by setting values on the function.</p><p>For example, from <a target="_blank" title="" href="/Classes/ibg">/Classes/ibg</a>, the following values control how the updateNode function is exposed to the web:</p><pre style="margin-left: 40px;">updateNode.webCallable = "POST_application_x_www_form_urlencoded";<br>updateNode.minimumWebPermission = "Write";<br>updateNode.parser_id = "number";<br>updateNode.webReturnConvention = "JavaScriptObject";<br>function updateNode(id, version, contents, changetag)<br>{<br></pre><p>The .webCallable is the only value that is needed to expose a function to the web.&nbsp; The rest of the values give finer control over how ObjectCloud accesses the function.&nbsp; These values are described throughout this section.</p><h2>.webCallable</h2><p>All functions that are exposed to the web must have their .webCallable value set.&nbsp; This value tells ObjectCloud what HTTP method is used, and how the arguments are encoded.&nbsp; The following are the valid values for .webCallable:</p><ul><li><span style="font-weight: bold;">GET</span>:&nbsp; Function is called with an HTTP GET.&nbsp; No arguments are passed.</li><li><span style="font-weight: bold;">GET_application_x_www_form_urlencoded</span>:&nbsp; Function is called with an HTTP GET.&nbsp; Arguments are passed as url-encoded values in the URL.</li><li><span style="font-weight: bold;">POST_application_x_www_form_urlencoded</span>:&nbsp; Function is called with an HTTP POST.&nbsp; Arguments are passed as url-encoded values in the POST body.</li><li><span style="font-weight: bold;">POST_string</span>:&nbsp; Function is called with an HTTP POST.&nbsp; A single value is passed, it is included in the POST body as a string.<br></li></ul><p>The GET calling conventions should be used for functions that primarily read, and the POST calling conventions should be used for functions that primarily write.&nbsp; This is due to the HTTP semantics of GET versus POST.&nbsp; Typically, GET requests aren't supposed to change the server's state; except for inconsequential actions like logging.</p><h2><span style="font-weight: bold;"></span>.minimumWebPermission</h2><p>By default, when a function is exposed to the web, only a person with "Administer" permission to the <span style="text-decoration: line-through;">file</span> object can call the function.&nbsp; The minimum permission can be lowered to "Write" or "Read" by specifying the .minimumWebPermission.</p><p>The following values are valid for .minimumWebPermission:</p><ul><li><span style="font-weight: bold;">Read</span></li><li><span style="font-weight: bold;">Write</span>&nbsp; (A person with Write access can also call functions that require Read access)<br></li><li><span style="font-weight: bold;">Administer</span>&nbsp; (A person with Administer access can call all functions.)<br></li></ul><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">In some circumstances, server-side Javascript can call into other objects.&nbsp; In these circumstances, it can utilize an elevated permission.&nbsp; This is described in the Elevate() section.&nbsp; A server-side Javascript function can declare a lower permission with the .minimumLocalPermission value.</span><br></p><h2>.namedPermissions</h2><p>Sometimes "Read", "Write", and "Administer" aren't fine grained enough to effectively control who can access what function.&nbsp; Named Permissions allows for more specific permissions for groupings of functions.</p><p>The .namedPermissions value takes a comma-seperated list of valid named permissions for a function.&nbsp; Any user who has a named permission for the file, is a member of a group that has a named permission for a file, or has such a named permission at a higher-level directory with inhert turned on can call the function.</p><p>TODO:&nbsp; Setting named permissions is currently undocumented, although it is anticipated that named permissions will require some form of a custom GUI in order to set.<br></p><h2>.parser_*</h2><p>Sometimes, ObjectCloud needs a hint about what kind of data the function expects in an argument.&nbsp; By default, ObjectCloud will treat all arguments as strings.&nbsp; Although Javascript's weak typing system can automatically translate some strings into numbers or booleans, this behavior occasionally introduces non-deterministic behavior and unintended side effects.&nbsp; The .parser_* values are used in situations where a number, boolean, or JSON-encoded object is expected.&nbsp; Valid values are:</p><ul><li><span style="font-weight: bold;">number</span>:&nbsp; ObjectCloud attempts to parse the argument into a double-precision value.&nbsp; If parsing fails, the string is passed as-is.<br></li><li><span style="font-weight: bold;">bool</span>:&nbsp; ObjectCloud attempts to parse the argument into a boolean value.&nbsp; If parsing fails, the string is passed as-is.<br></li><li><span style="font-weight: bold;">JSON</span>:&nbsp; ObjectCloud attempts to decode a JSON-encoded object.&nbsp; If parsing fails, a 422 (Unprocessable Entity) is returned to the caller.</li></ul><p>For example:</p><pre style="margin-left: 40px;">myfunc.webCallable = "POST_application_x_www_form_urlencoded";<br>myfunc.parser_argAsNum = "number";<br>myfunc.parser_argAsBool = "bool";<br>myfunc.parser_argAsJSON = "JSON";<br>function myfunc(argAsNum, argAsBool, argAsJSON)<br>{<br></pre><h1>.webReturnConvention</h1><p>The .webReturnConvention is an optional field that describes how the client will handle the returned data.&nbsp; ObjectCloud uses .webReturnConvention to help Javascript that runs in the browser parse the results of the server-side call.&nbsp; Valid values are:</p><ul><li><span style="font-weight: bold;">Primitive</span>:&nbsp; The function returns a string, number, or boolean.<br></li><li><span style="font-weight: bold;">JSON</span>:&nbsp; The function either returns an object, or a string that is a JSON-encoded object.&nbsp; The browser-side Javascript will get an automatically-decoded object.<br></li><li><span style="font-weight: bold;">JavaScriptObject</span>:&nbsp; The function either returns an object, a string that is a
JSON-encoded object, or Javascript.&nbsp; This will be eval()-ed and its result passed to the browser-side Javascript.</li><li><span style="font-weight: bold;">Status</span>:&nbsp; No value is returned to the browser-side Javascript.<br></li><li><span style="font-weight: bold;">Naked</span>:&nbsp; The browser-side Javascript gets un-parsed results.<br></li></ul><p>JSON and JavaScriptObject allow a server-side function to return an object that is transparently serialized and then de-serialized for browser-side Javascript.&nbsp; There is a speed / security tradeoff, described below.<br></p><div style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">The difference between JSON and JavaScriptObject is very important.&nbsp; "JSON" will make the browser use Prototype.js's </span><a style="font-style: italic;" target="_blank" title="" href="http://www.prototypejs.org/api/string/evalJSON">String.evalJSON()</a><span style="font-style: italic;"> function to parse the results; "JavaScriptObject" will make the browser use </span><a style="font-style: italic;" target="" title="" href="http://en.wikipedia.org/wiki/Eval#JavaScript">eval()</a><span style="font-style: italic;"> to parse the object.&nbsp; "JavaScriptObject" is much faster then "JSON," but it can introduce a security risk.&nbsp; Only use "JavaScriptObject" when returning objects that ObjectCloud will serialize to JSON, or when using strings that are validated to be pure JSON.&nbsp; Future versions of ObjectCloud might introduce a filter for JSON and rely on eval().&nbsp; Feedback on this issue is encouraged.</span><br></div><h1>Calling a Server-Side function from In-Browser Javascript</h1><p>The eventual purpose of server-side Javascript is to save data on the server.&nbsp; All of the underlying object's functions are placed within the base object.</p><p>For example, <a target="_blank" title="" href="/Classes/ibg">/Classes/ibg</a> turns a name-value pairs <span style="text-decoration: line-through;">file</span> object with a .ibg extension into a linked list.&nbsp; The function updateNode updates the contents of a node in the linked list.&nbsp; Prior to updating the node, it loads the node and verifies that the caller has the correct version:</p><pre style="margin-left: 40px;">// updateNode<br><br>updateNode.webCallable = "POST_application_x_www_form_urlencoded";<br>updateNode.minimumWebPermission = "Write";<br>updateNode.parser_id = "number";<br>updateNode.webReturnConvention = "JavaScriptObject";<br>function updateNode(id, version, contents, changetag)<br>{<br>   var nodeAsString;<br>   elevate(function()<br>   {<br>      nodeAsString = <span style="background-color: rgb(255, 255, 51);">base.Get(id);</span><br>   });<br>   <br>   var node = eval('(' + nodeAsString + ')');<br><br>   throwExceptionOnForbiddenChange(node, contents);<br><br>   if (node.v != version)<br>      throwWebResultOverrideException(400, "Wrong version");<br><br>   if (node.c != contents)<br>   {<br>      node.c = contents;<br>      node.v = updateVersionNumber(node.v);<br>      node.t = changetag;<br><br>      nodeAsString = JSON.stringify(node);<br>      elevate(function()<br>      {<br>         <span style="background-color: rgb(255, 255, 51);">base.Set(id, nodeAsString);</span><br>      });<br>   }<br><br>   return node;<br>}<br></pre><p>In the above example, the base.Get() and base.Set() functions call into the underlying name-value pairs object to persist the node's contents.&nbsp; Calls to base must be made within the context of an elevate() call, documented later.<br></p><h1>Built-in Metadata</h1><p>The following metadata is available for use at runtime:</p><ul><li><span style="font-weight: bold;">fileMetadata.filename</span>:&nbsp; The filename of the current object<br></li><li><span style="font-weight: bold;">fileMetadata.fullpath</span>:&nbsp; The full path to the current object<br></li><li><span style="font-weight: bold;">fileMetadata.url</span>:&nbsp; The full URL to the current object<br></li><li><span style="font-weight: bold;">userMetadata.id</span>:&nbsp; The current user's ID<br></li><li><span style="font-weight: bold;">userMetadata.name</span>:&nbsp; The current user's name<br></li><li><span style="font-weight: bold;">userMetadata.identity</span>:&nbsp; The current user's OpenID<br></li><li><span style="font-weight: bold;">hostMetadata.host</span>:&nbsp; The host name, including ":port" if the port isn't port 80<br></li><li><span style="font-weight: bold;">hostMetadata.justHost</span>:&nbsp; Just the host name without the port<br></li><li><span style="font-weight: bold;">hostMetadata.port</span>:&nbsp; The host's port.<br></li></ul><h1>Additional Built-in Functions</h1><p>Server-side Javascript provides some additional methods to assist in returning more detailed data to the browser and for working with ObjectCloud<br></p><h2>generateWebResult(status, message)<br></h2><p>The generateWebResult function allows closer control over the status returned to the browser.&nbsp; The first argument, status, takes a number that is the status code returned to the browser.&nbsp; The second argument, which is optional, is the message returned to the client.&nbsp; ObjectCloud treats the message argument as a string.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">Feedback on how to handle the message is welcome and appreciated.</span><br></p><h2>throwWebResultOverrideException(status, message)</h2><p>The throwWebResultOverrideExcetion function throws a special kind of exception.&nbsp; Assuming that this exception isn't caught in the server-side Javascript, when it is thrown into ObjectCloud, it will abort all calls and return the result directly to the browser.&nbsp; This is useful from within elevate() or callAsOwner().<br></p><h2>JSON</h2><p>The /API/json2.js is automatically loaded to provide secure JSON functionality.&nbsp; /API/Prototype.js isn't used in server-side Javascript because it only runs within a browser.<br></p><h3>JSON.parse(toParse)</h3><p>The parse function is a secure way of parsing a JSON object encoded as a string.&nbsp; When handling untrusted data, the parse function will not allow a hacker to inject malicious Javascript.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">eval() is much faster then calling parse().&nbsp; When working with trusted JSON strings, eval() is recommended.</span><br></p><h3>JSON.stringify()<br></h3><p>Stringify takes a Javascript object and returns it encoded as a JSON string.<br></p><h2>lockMe(function)</h2><p>Locks the object and calls the function.&nbsp; When the function is called, it has exclusive access to the underlying object.<br></p><h2>elevate(function)</h2><p>Calls the function with an elevated security context.&nbsp; When calling into other objects, the "minimumLocalPermission" instead of "minimumWebPermission" will be used.&nbsp; See the later section, "Calling into other Objects," to learn how to call into other objects.</p><p>elevate must be used to call into the base object.<br></p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">Validate all input before calling this function, as a malicious user could gain access to sensitive data or corrupt sensitive data</span>.<br>
</p>
<h2>callAsOwner(function)</h2><p>Calls the function as if the object's owner is calling it.</p><p style="margin-left: 40px;"><span style="font-weight: bold;">Note</span>:&nbsp; <span style="font-style: italic;">Validate all input before calling this function, as a malicious user could gain access to sensitive data or corrupt sensitive data</span>.<br></p><h2>sanitize(html)</h2><p>Sanitizes the passed in html.&nbsp; Removes potential cross-site scripting attacks and unclosed tags.&nbsp; This should be called on all HTML that is displayed to the user.<br></p><h1>Calling into other Objects<br></h1><p>Server-side Javascript uses the same // Scripts: syntax that client-side Javascript uses.&nbsp; This allows another object to be loaded.&nbsp; For example, from <a target="_blank" title="" href="/Tests/Classes">/Tests/Classes</a>:</p><pre style="margin-left: 40px;">// Scripts: /System/Proxy?Method=GetServersideJavascriptWrapper&amp;assignToVariable=Proxy<br></pre><p>The method GetServersideJavascriptWrapper returns an object that grants access to the <a target="_blank" title="" href="/System/Proxy">/System/Proxy</a> object by creating the "Proxy" object in the server-side Javascript.&nbsp; An example of accessing the "Proxy" object is:</p><pre style="margin-left: 40px;">TestElevateProxyGet.webCallable = "GET";<br>function TestElevateProxyGet()<br>{<br>   return elevate(function()<br>   {<br>      return <span style="background-color: rgb(255, 255, 51);">Proxy</span>.GET("http://slashdot.org", {}).Content;<br>   });<br>}<br></pre><p>In the above example, the Proxy object is used to make a GET request to http://slashdot.org.&nbsp; The <a target="_blank" title="" href="../System/Proxy">/System/Proxy</a> requires elevated security in order to call.</p><p><a href="about.page">About ObjectCloud</a></p>