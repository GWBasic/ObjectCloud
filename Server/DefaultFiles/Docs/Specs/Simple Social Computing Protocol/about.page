{"Title":"Simple Social Computing Protocol: About","Contents":"\n<p>The Simple Social Computing Protocol is designed to enable social networking use cases in a distributed manner. Users may use any server on the public internet, as opposed to centralized social networking services. It&#160;addresses the following use cases:</p><p><ul><li>User shares a web-accessible item, like a status update, image, movie, event invitation, or hyperlink, with another person or group of people.</li><li>User links an item to another web-accessible item, such as replying to a status update, or commenting on an image.</li><li>Server verifies that a message from another user actually comes from that user. (Eliminates the spoofing problem in email.)</li><li>One user adds another user as a friend.</li></ul></p><p>The protocol is designed such that simple implementations can exist without having to implement lots of protocols. It leaves room for expansion by delegating different data types, (images, movies, events, ect,) to convention. Furthermore, it's designed such that implementations that do not understand data types can still handle such incoming data, although at a less-optimal user experience.</p><p>The Simple Social Computing Protocol replaces the <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://objectcloud.kicks-ass.net/Docs/Specs/Particle.page\">Particle protocol used in early versions of ObjectCloud</a>.</p><p>SSCP is inspired by <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://ostatus.org/\">OStatus</a>. The difference is that SSCP is designed for private data, and to keep the protocol simple. SSCP isn't designed for high-volume&#160;situations&#160;where a user might have millions of followers. In these situations, SSCP&#160;recommends&#160;following standards like PubHubSubBub and Salmon for public data.</p><h1>Overview</h1><p>In SSCP, all users are identified with <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://code.google.com/p/webfinger/\">WebFinger</a>. This gives users email-like identifiers, which are well-known in the non-technical community. OpenID and XRI identifiers are not supported.</p><p>In order to avoid spoofing, and to control SPAM, all server-to-server messages must be cryptographically-signed. SSCP defines <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"signatures.page\">Signed BSON</a>&#160;to do this. Signed BSON is based off of Salmon's <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-00.html\">Magic Signatures</a>, which is based off of XML-Dsig, but uses <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://bsonspec.org/\">Binary JSON</a>&#160;to eliminate ambiguities that arise when trying to sign XML or JSON.</p><p>SSCP uses a recipient's WebFinger to discover an XRD document. It then sends messages to the user's \"sscp.message\" endpoint. All messages, such as status updates, links (replies), shared images, ect, have type and a short xhtml summary. Servers that do not know how to handle a specific type can fall back to the xhtml summary. All messages are tied to a specific URL. As stated above, all messages are Signed BSON to prevent spoofing.</p><p>SSCP&#160;recommends&#160;that servers support some form of friending and/or following. It&#160;recommends, but does not require, that messages from someone that isn't a friend, or isn't being followed, are either discarded or hidden.</p><p>Friending is supported in two steps. When displaying an \"Add user as a friend\" on a user's profile, the server handles the button by looking up the currently-logged-in user's XRD document and finding the \"sscp.friend\" endpoint. The currently-logged-in user's browser is then directed to POST to the specified endpoint. Friendship requests are then sent as a well-known type of message.</p><p><br/></p>"}