<div>NodeProcess.js:  Node.js as a Sub-Process</div>
<blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><b>Note</b>: &nbsp;<i>This document contains some musings about potentially using Node.js to host V8 in a sub-process. &nbsp;It is very incomplete.</i></p></blockquote><p><br></p><p><br></p><p>There are many Javascript libraries like Spidermonkey, Rhino and Google's V8 that allow an application designer to incorporate lightweight user-generated programs. &nbsp;These libraries allow the programmer to expose functionality in a rather secure manner; as the programmer can deterministically expose a limited set of well-known functions for user-generated code to use.</p><blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><b>Note</b>: &nbsp;<i>A potential complexity is that Node gives access to the underlying filesystem. &nbsp;This could create non-deterministic security holes.</i></p></blockquote><p>A limitation in these libraries is that they aren't universally supported in different platforms. &nbsp;Specifically, Rhino is only callable from Java, and Google's V8 is only callable from C++. &nbsp;This can sometimes severely limit an application designer's choice in finding a robust Javascript library. &nbsp;This is the case for ObjectCloud, where there are no well-supported Javascript interpeters for .Net.</p><p>This document describes NodeProcess.js, a different approach whereby Node.js hosts a Javascript interpreter in a&nbsp;separate&nbsp;process then the main application, and uses a socket to communicate between the two processes. &nbsp;While "heavier" then hosting an interpreter as an in-process library; a multi-process&nbsp;architecture&nbsp;has robustness and security benefits. &nbsp;These are seen in Google Chrome where a misbehaving sub-process, when killed, allows other pages to remain open.</p><blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><b>Note</b>: &nbsp;<i>This specification is written from the viewpoint of how ObjectCloud currently uses Javascript. &nbsp;There may be other needs that aren't captured here.</i></p></blockquote><h1>Creating a Javascript Sub-Process</h1><blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><b>Note</b>: &nbsp;<i>This section makes many assumptions about how Node operates. &nbsp;Some, or all, assumptions may be invalid, thus&nbsp;requiring&nbsp;significant revision.</i></p></blockquote><p>When an application starts a NodeProcess.js sub-process, it passes three command-line arguments:</p><p></p><ul><li><b>Server</b>: &nbsp;This is typically "localhost"</li><li><b>Port</b>: &nbsp;The port</li><li><b>Code</b>: &nbsp;Connection code</li></ul>When NodeProcess.js starts, it opens a socket to the specified server and port. &nbsp;As soon as the socket is connected, it sends the code through the socket. &nbsp;Once the socket is disconnected, NodeProcess.js disconnects. &nbsp;In theory, when the client library is disposed or released (according to the semantics of the main processes's environment,) it should close the socket so that the sub-process can end.<p></p><h1>Communication</h1><p>Communication between the main process and NodeProcess.js is two-way and non-blocking. &nbsp;The main process is able to send&nbsp;arbitrary&nbsp;Javascript to execute, call functions by ID, and can request metadata about the available functions to call.<br></p><p>Every time a call is made, a string length ending in a semicolon is sent. &nbsp;After the string length, a JSON object is sent that is the exact length as specified by the string length. &nbsp;The value for "command" is the name of the command, and all other values depend on the specific string.</p><p>For example:</p><blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>50;{"command":"eval","js":"return 1+1;","id":6236354}</p></blockquote><h2>Main Proccess Commands</h2><p>The following commands can be sent through the socket from the main process to the sub-process:</p><p></p><ul><li><b>eval</b>: &nbsp;Evaluates Javascript on the server</li><li><b>getfuncs</b>: &nbsp;Returns information about functions that can be called</li><li><b>setfunc</b>: &nbsp;Specifies a function in the main process that Javascript in NodeProcess.js can call.</li></ul><h3>eval</h3><p>The expected properties in the eval command are:</p><p></p><ul><li><b>js</b>: &nbsp;The javascript to evaluate with eval(...)</li><li><b>id</b>: &nbsp;The id to use when returning the results. &nbsp;(See the return command)</li></ul><p></p><p>Eval uses Javascript's eval() statement to evaluate the given string.</p><blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px; border: none; padding: 0px;"><p></p></blockquote><p></p><p><br></p><p></p><p>The following commands can be sent through the socket from either the main process to the sub-process, or the sub-process to the main process.</p><p>&nbsp;<b>callfunc</b>: &nbsp;Calls a specific function by ID. &nbsp;This can either be a function declared in "eval," or a callback.<br></p><meta charset="utf-8"><h1>Data Representations</h1><p><br></p>