{"Title":"Particle - Implementation","Contents":"<h1></h1><h1 style=\"font-weight: normal; font-size: medium; \"></h1><h1><span class=\"Apple-style-span\" style=\"font-weight: normal; font-size: medium;\"><meta charset=\"utf-8\"/><h1><span class=\"Apple-style-span\" style=\"font-weight: normal; font-size: medium; \">This document contains the design for ObjectCloud's&#160;implementation&#160;of the Particle notification system. &#160;It discusses things like database schemas and placement within ObjectCloud.</span></h1><h1 class=\"western\">Overview</h1></span><p>Persisting data regarding senderTokens, avatars, and loginURLs is stored globally for the entire server. &#160;senderTokens and loginURLs are stored in /Users/UserDB. &#160;Avatars are stored as flat files in /Users/ParticleAvatars.</p><p>Every user will have an embedded database to store their notifications. Scaling is handled by each user having their own separate database.</p><p>The user object will handle the particle database. Per the existing ObjectCloud design, the user object is:</p><p style=\"margin-left: 0.49in; \">/Users/TheUser.user</p><h1 class=\"western\">TODOs:</h1><p></p><ul><li>WebFinger</li><li>SSL</li><li>450 (blocked) response to a notification</li><li>Deletion / ignoring in general</li><li>Proxying img tags in summary views so that images aren't too big</li><li>Thick client sessions will be untested, but the endpoint will be /System/UserDB?Method=Login</li><li>Updating an object's state</li><li>Reliability and retry when sending notifications. &#160;(Notifications aren't retried, unsent notifications aren't persisted to DB in case of a server crash)</li><li>Blocking users and domains</li><li>Groups (notification sent to all members of a group, but there needs to be a concept of a group with a page)</li><li>Friends</li></ul><p></p><h1 class=\"western\">Schema</h1><p>The Schema design is divided into two parts; the global schema for the entire server, then then the user-specific schema where each user has their own unique set of tables.</p><p>Because ObjectCloud uses SQLite, the schema is designed around SQLite semantics. &#160;This is why, for example, that users have&#160;separate&#160;tables for their personal data instead of normalizing data into a completely global set of tables.</p><h2>Server-Wide Storage</h2><p>Globally, senderTokens, avatars, and loginURLs are stored. &#160;There currently is no design for a server-wide whitelist or blacklist.</p><p>Avatars are stored in /Users/ParticleAvatars. &#160;The filename is the base64-encoded string of either the OpenID or WebFinger, with a \".jpg\" extension. &#160;This allows use of the \"?Method=GetScaled\" convention and \"&amp;BrowserCache\" conventions.</p><p>When establishing trust, all data is stored in RAM.</p><p>The following SQLite tables are in /Users/UserDB:</p><p></p><ul><li><b>Sender</b>: Stores information about senders from other servers. Includes senderTokens and loginURLs.</li><li><b>Recipient</b>: &#160;Stores information about senders from this server. &#160;Includes senderTokens.</li></ul><h3>Sender Table</h3><p>The sender table stores information used when a sender is from another server. &#160;It has the following columns:</p><p></p><ul><li><b>senderID</b>: &#160;SQLite numeric primary key</li><li><b>name</b>: &#160;Either an OpenID or WebFinger, string, unique</li><li><b>senderToken</b>: &#160;The senderToken that the sender must use to authenticate, string, unique</li><li><b>loginURL</b>: &#160;The URL to POST to when logging into this server with OpenID, string</li><li><b>loginURLOpenID</b>: &#160;The POST argument for the user's OpenID, string</li><li><b>loginURLWebFinger</b>: &#160;The POST argument for the user's webfinger if used instead of OpenID, string</li><li><b>loginURLRedirect</b>: &#160;The POST argument for the URL that the user will be redirected to, string</li></ul><p></p><h3>Recipient Table</h3><p>The recipient table is used when sending a notification to another server.</p><p></p><ul><li><b>userID</b>: &#160;UserID of a local (not OpenID) user or group.</li><li><b>receiveNotificationEndpoint</b>: &#160;The recieveNotification endpoint that this senderToken is valid for.</li><li><b>senderToken</b>: &#160;The senderToken to use for the endpoint.</li></ul><p>The combination of userID and recieveNotificationEndpoint are unique.</p><h2>User-Specific Storage</h2><p>Each user has their own SQLite database for notifications. &#160;Notifications are deliberately&#160;de-normalized&#160;for each user as a means of keeping the reference implementation simple and enabling some acceptable performance for&#160;hobbyists.</p><p>As of now, the only table implemented is Notification. &#160;Blocking, managing ObjectState, and deleting is not yet supported.</p><p>TODO: &#160;Groups may eventually support&#160;receiving&#160;notifications directly, thus they may need to have these tables.</p><h3>Notification Table</h3><p>Each notification is stored in this table.</p><p></p><ul><li><b></b></li><li style=\"display: inline !important; \"><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>notificationId</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \">: SQLite primary key, starts at 0 and automatically increments.</span></li><b></b><b></b><li><span class=\"Apple-style-span\" style=\"font-weight: normal; \"></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>timeStamp</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \">: The exact date/time that the row was created. Not null, and if possible, the schema should automatically create the timeStamp.</span></li><li><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>senderID</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \">: The sender's ID as stored in the Sender table in /Users/UserDB, indexed</span></li><li><b>objectUrl</b>: The URL to the document, string, indexed</li><li><b>summaryView</b>: &#160;The document's summary view. &#160;string</li><li><b>documentType</b>: The document type. string, indexed</li><li><b>verb</b>: &#160;String</li><li><b>changeData</b>: &#160;As sent in the notification, string</li><li><b>linkedSenderID</b>: &#160;The OpenID or WebFinger of the sender.</li></ul><h1>Getting information from an OpenID or WebFinger</h1><p>Generally, endpoints discovered from an OpenID or WebFinger are held in RAM for no more then 24 hours. &#160;This is to keep the implementation simple, as it is easiest to program with RAM-only data, and because lost data can be easily recovered.</p><p>The UserManagerHandler object will have an asyncronous GetEndpoints function. &#160;It will use a callback to return a strongly-typed object with discovered endpoints.</p><h1>Establishing Trust with particle.establishTrust and particle.respondTrust</h1><p>General comments:</p><p>Implemented completely in /Users/UserDB</p><p>Tokens sent when making a call to or from particle.establishTrust are held in RAM for simplicity reasons.</p><p></p><p>Tokens are generated by base64-encoding 100 random bytes.</p><p>For security reasons, the Sender table should only be updated if particle.respondTrust is successful. This is to prevent malicious attacks that would invalidate senderTokens.</p><p>Due to the design of establishing trust, the senderToken isn't returned by a call to establishTrust. Instead, the recipient verifies that the sender is the OpenID that it claims to be by calling respondTrust.</p><h1>Sending Notifications</h1><p>Steps:</p><p><ol><li>Resolve all groups so that there is a complete list of users, (except for the everybody group.)</li><li>Resolve or use pre-cached lists of endpoints for all remote users</li><li>Establish trust, if needed</li><li>Send notifications to unique recieveEndpoint endpoints</li></ol></p><h1>Receiving&#160;Notifications</h1><p>The /Users/UserDB object will handle incoming notifications. &#160;It will distribute notifications to each recipient.</p><p>(See the particle notification spec for the arguments, no use copying)</p><p></p><p></p><ol><li>The Sender table is queried to find the OpenID from the senderToken. If no matching senderToken is found, then an HTTP status 424 (failed dependancy.) and the text &#160;\"senderToken\" are returned.</li><li>Future: The Blocked table is queried for the OpenID. If it is found, then a 202 is returned and the notification discarded.</li><li>If the verb is link, ensure that there is an avatar for the user who owns the linked object.</li><li>The notification is then sent to each recipient's RecieveNotification method on their user object.</li></ol>For each user:<br/><ol><li>Future: The Blocked table is queried for the OpenID's domain and all parent domains. If any are found, then a 202 is returned and the notification discarded.</li><li>Future: The ObjectState table is queried for an entry with the objectUrl,&#160;If the state is deleted, then the 450 (Blocked) HTTP status code is returned. The ignored and silent delete statuses cause a 202 status code to be returned. (The method returns in these cases and the rest of the steps are ignored.)</li><li>The data is then entered into the Notification table.</li><li>Comet updates are sent so Notifications can appear in real time.</li></ol><p></p><p></p><p></p><p></p><p style=\"font-weight: normal; \">Note: The senderToken is verified before any kind of state about the object is returned. This is to prevent malicious entities from learning about private data.</p><h1>particle.establishSession</h1><p style=\"font-weight: normal; \">This is /Users/UserDB's Login method.</p><h1>particle.getNotifications</h1><p style=\"font-weight: normal; \">This is implemented as a web-accessible method on each user's object. &#160;/Users/username.user. &#160;A session must be established as the user who's notifications are being read, or as a system administrator.&#160;The method constructs a dynamic SQL query based on the user's arguments.</p><p style=\"font-weight: normal; \">(TODO: &#160;What about sending notifications to groups?)</p><p style=\"font-weight: normal; \">(See the spec's section for this endpoint to see the arguments.)</p><ol><li><p style=\"font-weight: normal; \">The query is constructed:</p><ol><li><p style=\"font-weight: normal; \">By default, all columns are selected</p></li><li><p style=\"font-weight: normal; \">The where clause is built using newestNotificationId, oldestNotificationId, objectUrl, and sender.</p></li><li><p style=\"font-weight: normal; \">The query is ordered by NotificationId in a descending order.</p></li><li><p style=\"font-weight: normal; \">If maxNotifications is sent, then a \"MAX\" clause is appended.</p></li></ol></li><li><p style=\"font-weight: normal; \">The results are returned. As the schema matches the standard, no object conversion needs to be made.</p></li></ol><h1>Friends and Followers</h1><p>All users will have two groups generated for the user:</p><p><ul><li><b>Followers</b>: &#160;Anyone can join this group, twitter-style.</li><li><b>Friends</b>: &#160;A Facebook-style group where the user must manually approve who is a member. &#160;As of this time there is no UI conventions or protocol for requesting to be a friend, it is TODO.</li></ul></p><h1>Template System Modifications</h1><p>Not sure if needed, will try to handle without special tags.</p><h1>Summary View Support</h1><p>In order to support notifications, object types will need summary view support.</p><p>Summary view templates will be in /Shell/Viewers/SummaryViews. &#160;The convention will be [file extension].occ. &#160;Thus, mypage.page will use /Shell/Viewers/SummarViews/page.occ for the summary view.</p><p>When generating the summary view, the \"current user\" will be the owner of the object. &#160;Summary View creators must use care not to expose sensitive information that will be distributed to all recipients.</p><h1>Old Parts of the spec</h1><p>Some old parts of the spec remain from when the spec was designed to be more of a Wave-like protocol. &#160;These parts will be useful when implementing unimplemented features, like blocking, deleting, and changing state.</p><p>These parts of the spec are left below.</p><div><br/></div><div><p>Because Objectcloud's embedded databases are SQLite, the schema is designed around this database.</p><p>The following tables are used in each user's Particle notifications database:</p><ul><li><p><b>Blocked</b>: Blocked OpenID users and domains.</p></li><li><p><b>ObjectState</b>: Stores information about objects through their objectUrls. Includes information about their ignore and delete status.</p></li><li><p><b>Deleted</b>: Stores information about recipients and objects that they have requested not to receive notifications for.</p></li></ul><h2 class=\"western\" style=\"font-weight: normal; \">Blocked Table</h2><p style=\"font-weight: normal; \">Contains blocked OpenIDs and domains</p><p style=\"font-weight: normal; \">Columns:</p><ul><li><p><b>openIDorDomain</b><span style=\"font-weight: normal; \">: An OpenID or domain. These are merged together because some OpenIDs are domains.</span></p></li></ul><h2 class=\"western\" style=\"font-weight: normal; \">ObjectState</h2><p style=\"font-weight: normal; \">Stores information about the state of an object. If the object has no entry in this table, then its state is unignore.</p><p style=\"font-weight: normal; \">Columns:</p><ul><li><p><b>objectUrl</b><span style=\"font-weight: normal; \">: The object's URL that is sent with a notification. Not null.</span></p></li><li><p><b>objectState</b><span style=\"font-weight: normal; \">: Either \"i\" for ignore, \"d\" for deleted, or \"s\" for silently deleted. Not null.</span></p></li></ul><p style=\"font-weight: normal; \">If an object is to be unignored, then its entry is removed from the table.</p><h2 class=\"western\" style=\"font-weight: normal; \">Deleted Table</h2><p style=\"font-weight: normal; \">The deleted table stores information about objects that recipients have requested not to receive future notifications.</p><p style=\"font-weight: normal; \">Columns:</p><ul><li><p><b>objectUrl</b><span style=\"font-weight: normal; \">: The object's url. Not null.</span></p></li><li><p><b>openId</b><span style=\"font-weight: normal; \">: The OpenID that requested that it no longer receive notifications about the given object.</span></p></li></ul></div><h2 class=\"western\" style=\"font-weight: normal; \"><br/></h2><h2 class=\"western\" style=\"font-weight: normal; \">particle.establishTrust</h2><p style=\"font-weight: normal; \">Implemented in the server-side Javascript \"EstablishTrust\" method.</p><ol><li><p style=\"font-weight: normal; \">The senders endpoints are found by calling GetEndpoints for the given OpenID.</p></li><li><p style=\"font-weight: normal; \">A new senderToken is randomly generated. It is verified to be unique.</p></li><li><p style=\"font-weight: normal; \">The particle.respondTrust endpoint is called. The token value is passed directly without modification, and the newly-generated senderToken is sent as well.</p></li><li><p style=\"font-weight: normal; \">If respondTrust succeeds, then an entry in the Sender table is either created or updated.</p></li></ol><p><br/></p><h2 class=\"western\" style=\"font-weight: normal; \">Establishing Trust / Getting a senderToken.</h2><p style=\"font-weight: normal; \">This server-side Javascript method is used internally, such as when a notification is sent. The method is named \"GetSenderToken\". It takes two arguments:</p><ol><li value=\"1\"><p><b>openID</b><span style=\"font-weight: normal; \">: The OpenID, string.</span></p></li><li><p><b>forceRefresh</b><span style=\"font-weight: normal; \">: Optional, a boolean, if set to true, then a refresh is forced.</span></p></li></ol><p style=\"font-weight: normal; \">If forceRefresh is missing or false, and there is an entry in the Sender table with the given OpenID and its recipientToken isn't null, then the recipientToken is returned. Elsewise, the method continues to establish trust with the given OpenID.</p><p style=\"font-weight: normal; \">To establish trust:</p><ol><li><p style=\"font-weight: normal; \">An entry is created in the sender table if it is not there.</p></li><li><p style=\"font-weight: normal; \">A randomly-generated token is made.</p></li><li><p style=\"font-weight: normal; \">The token is validated to make sure it's unique.</p></li><li><p style=\"font-weight: normal; \">An entry is made in the Token table.</p></li><li><p style=\"font-weight: normal; \">GetEndpoints is called to get the endpoints.</p></li><li><p style=\"font-weight: normal; \">The OpenID's establishTrust endpoint is called. The token and this user's OpenID are sent.</p></li><li><p style=\"font-weight: normal; \">If it returns success, then GetSenderToken recurses to re-load the recipientToken. (It's entered into the database because establishTrust blocks while the new senderToken is sent to respondTrust.) If failure is returned, then an exception is thrown.</p></li></ol><p style=\"font-weight: normal; \">Notes:</p><p style=\"font-weight: normal; \">Due to the design of establishing trust, the senderToken isn't returned by a call to establishTrust. Instead, the recipient verifies that the sender is the OpenID that it claims to be by calling respondTrust.</p><h2 class=\"western\" style=\"font-weight: normal; \">particle.respondTrust</h2><p style=\"font-weight: normal; \">When establishing trust with a recipient, the recipient calls this endpoint to verify that the sender is as claimed. This is to prevent spoofing. It is implemented in server-side Javascript as \"RespondTrust\", and takes two arguments:</p><ol><li><p><b>token</b><span style=\"font-weight: normal; \">: The token that this user sent to the recipient.</span></p></li><li><p><b>senderToken</b><span style=\"font-weight: normal; \">: The token that the recipient will use to identify this sender.</span></p></li></ol><p style=\"font-weight: normal; \">The method has the following steps:</p><ol><li><p style=\"font-weight: normal; \">All entries in the Token table that are older then 180 seconds are deleted.</p></li><li><p style=\"font-weight: normal; \">An attempt is made to find the OpenID from the sent token. If there is no matching OpenID, then an error is returned.</p></li><li><p style=\"font-weight: normal; \">The Sender table's recipientToken is updated in the row identified with the loaded OpenID.</p></li><li><p style=\"font-weight: normal; \">The row from the Token table is deleted.</p></li></ol><h2 class=\"western\" style=\"font-weight: normal; \">particle.updateNotificationState</h2><p style=\"font-weight: normal; \">(See the spec's section for this endpoint to see the arguments.)</p><p style=\"font-weight: normal; \">This is implemented as a Javascript function called \"UpdateNotificationState\". A session must be established where the user has WRITE access. It uses an update query on the Notification table using the passed NotificationId to update the state column to r if read, or null if unread.</p><p style=\"font-weight: normal; \">All blocked calls to GetNotifications are unblocked.</p><h2 class=\"western\" style=\"font-weight: normal; \">particle.updateObjectState</h2><p style=\"font-weight: normal; \">(See the spec's section for this endpoint to see the arguments.)</p><p style=\"font-weight: normal; \">Server-side javascript function named \"UpdateObjectState\". A session must be established where the user has ADMINISTER access. An entry in the ObjectState table is either created or updated based on the passed-in state.</p><p style=\"font-weight: normal; \">If \"delete\" or \"silentDelete\" is passed in, then all notifications for the given object are deleted.</p><h2 class=\"western\" style=\"font-weight: normal; \">particle.block</h2><p style=\"font-weight: normal; \">(See the spec's section for this endpoint to see the arguments.)</p><p style=\"font-weight: normal; \">Implemented as \"Block\". A session must be established where the user has ADMINISTER access.</p><p><span style=\"font-weight: normal; \">The toBlock argument is used to make an entry in the Blocked table. OpenIDorDomain is set from toBlock. OpenIDs (<a href=\"http://fdfsgvdsf/\">http://fdfsgvdsf</a>) or domains (without http) can be sent. No input validation is performed.</span></p><p style=\"font-weight: normal; \">A 202 (Accepted) error code is returned if there are no errors.</p><h2 class=\"western\" style=\"font-weight: normal; \">particle.unBlock</h2><p style=\"font-weight: normal; \">(See the spec's section for this endpoint to see the arguments.)</p><p style=\"font-weight: normal; \">Implemented as \"UnBlock\". A session must be established where the user has ADMINISTER access.</p><p style=\"font-weight: normal; \">The toUnBlock argument is used to remove an entry in the Blocked table where OpenIDorDomain is toUnBlock.</p><p style=\"font-weight: normal; \">A 202 (Accepted) error code is returned if there are no errors.</p><h2 class=\"western\" style=\"font-weight: normal; \">particle.getBlocked</h2><p style=\"font-weight: normal; \">(No arguments.)</p><p style=\"font-weight: normal; \">Implemented as \"GetBlocked\". A session must be established where the user has READ access.</p><p style=\"font-weight: normal; \">All blocked domains and endpoints are returned as a single Javascript array with a 200 (OK) success code.</p></h1>"}