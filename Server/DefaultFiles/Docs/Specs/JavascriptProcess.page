<div>Javascript Sub-Process</div><h1>Overview</h1>

<p>There are many Javascript libraries like Spidermonkey, Rhino and Google's V8 that allow an application designer to incorporate lightweight user-generated programs.  These libraries allow the programmer to expose functionality in a rather secure manner; as the programmer can deterministically expose a limited set of well-known functions for user-generated code to use.  A limitation in these libraries is that they aren't universally supported in different platforms.  Specifically, Rhino is only callable from Java, and Google's V8 is only callable from C++.  This can sometimes severely limit an application designer's choice in finding a robust Javascript library.  This is the case for ObjectCloud, where there are no well-supported Javascript interpeters for .Net.</p>

<p>This document describes how ObjectCloud communicates with Javascript environments running in a sub-process.  Initially, to keep development, building, and deployment simple, the sub-process will be a Java sub-process using Rhino as a Javascript engine.  In the long term, a sub-process written in C++ using Google's V8 as a Javascript engine will implement the same communication protocol described here.  While "heavier" then hosting an interpreter as an in-process library; a multi-process architecture has robustness and security benefits.  These are seen in Google Chrome where a misbehaving sub-process, when killed, allows other pages to remain open.</p>

<h2>Need and Justification</h2>

<p>There are two reasons why ObjectCloud needs to run server-side Javascript in a sub-process instead of within its own process.  These are as follows:</p>

<ol>
<li><b>Stability</b>:  Poorly-written Javascript, when run in the same process as the server, could crash the entire server or hog too much CPU resources.  Such performance issues could impact all users of the server.  A real risk is that, while developing, a programmer accidentally introduces an infinite loop into server-side Javascript.  Another risk is that server-side Javascript could call an API that blocks in native platform calls.  In both situations, .Net's Thread.Abort() is not guaranteed to stop misbehaving Javascript.  In contrast; ObjectCloud can kill misbehaving sub-processes.  Thus, ObjectCloud must use a multi-process design for server-side Javascript.</li>
<li><b>.Net's Limitations</b>:  No good Javascript interpreters exist for .Net.  This is because .Net can not garbage collect executable code once it is loaded into RAM.  In Javascript, functions are treated like data, thus Javascript can only run well in environments that allow garbage collection of code.  This limitation can be worked around by interpreting Javascript, however interpreted Javascript is too slow for practical use. </li>
</ol>
<p>The early ObjectCloud prototype converted Rhino, a Java Javascript interpreter, into a .Net dll, but this proved to be too slow and unstable for ObjectCloud applications that made heavy use of server-side Javascript.  Work was also performed with Jint, a true Javascript interpreter for .Net; although Jint was too buggy and introduced too many .Net semantics into Javascript to meet ObjectCloud's needs.  As a result of work with Rhino converted to a .Net dll, and Jint, the conclusion is that the only way for ObjectCloud to reliably handle server-side Javascript is to run it in sub-processes written in languages that provide better Javascript support.</p>
<h2>Implementation Decisions</h2>

<p>The obvious best choice for a Javascript sub-process is a natively-compiled executable that uses Google's V8 Javascript engine.  This would yield the fastest Javascript possible; although it introduces some compromises in ObjectCloud's development philosophies:</p>

<ul>
<li>At this point, there are no standard V8 libraries commonly found on Windows, Mac, and Linux.  (In contrast, SQLite has standard libraries on all three.)  V8, and thus the executable, would need to be specially-compiled for each target platform.  Currently ObjectCloud runs on Windows, Mac, and Linux without any recompilation, as it is Andrew's philosophy that ObjectCloud should require as little as possible "work" to set up ObjectCloud anywhere.</li>
<li>C++ tends to have more complicated build issues compared against C# and Java.  One of Andrew's philosophies is to avoid things like make and stick with build environments that work in common IDEs.
Thus, the Javascript sub-process is written in such a way that it can run anywhere without platform-specific compilation; although the protocol between the parent ObjectCloud process and Javascript subprocess utilizes standard and well-defined techniques.  This allows a natively-compiled V8-based Javascript engine to be swapped in and replace the Java / Rhino subprocess.</li>
<li>For now, the Javascript subprocess is written in Java and uses Rhino.  This minimizes the development learning curve as it utilizes lessons learned from converting Rhino into a .Net dll.  Communication between the parent and child processes will use stdin and stdout.  This minimizes relying on sockets, as sockets can sometimes "fill up" on certain operation systems.  It also alleviates depending on platform-specific IPC systems, like named pipes.</li></ul>

<p>As stated earlier, the current implementation is a works-anywhere approach.  In the long-term, because the protocol is well-documented and universally available on all platforms, the Java and Rhino sub-process can be replaced with a V8 subprocess.  Another option is to use Node.js as a subprocess, however, that will require that Node.js gets good support on Windows, Mac, and Linux, and that Node.js allows true isolation with multiple contexts.  Its current implementation of evalcx() would mean that Javascript could pollute Node's parent global scope, which could then contaminate other scopes and the lower-level IO subsystem.  Node also exposes access to the underlying computer's API, which shouldn't be accessible in ObjectCloud's server-side Javascript for security and long-term portability needs.</p>

<h2>Capability and Behavior</h2>

<p>All communication between the parent and sub process occurs on the sub process's stdin and stdout using JSON.  The subproces supports multiple isolated scopes.  All communication should be treated as non-blocking; that is, the parent process can call many functions in different scopes concurrently.  Furthermore, the system is designed to emphasize compiling Javascript and caching of compiled Javascript.  This significantly improves performance as, in Rhino, compiling Javascript is time consuming, and compiled Javascript runs many orders of magnitude faster then interpreted Javascript.</p>

<p>In general, the following activities are supported:</p>

<ul>
<li>Parent process either compiles a Javascript script, the sub process returns the compiled Javascript.</li>
<li>Parent process sends precompiled Javascript to the sub process</li>
<li>Parent process creates a scope by indicating which pre-compiled scripts to run.  The subprocess returns metadata about the scope, including functions, through stdout.</li>
<li>Parent process disposes a scope.</li>
<li>Parent process calls a function in a scope.  The subprocess returns the function's results through stdout.</li>
<li>Subprocess calls a function that the parent process placed into its scope through stdout.  The parent process returns the results through stdin.</li>
<li>Parent process calls a callback function that was passed when the subprocess called one of its functions.  The subprocess returns the results  through stdout.</li>
</ul>

<p>Communication is described in detail in the Communication section.  Right now, the parent process can not hold references to objects that are passed to its functions beyond the lifetime of a function call.  This means that the parent process can not use callbacks for asynchronous communication and must call callbacks during a function call and not afterwards.
Creating a Javascript Sub-Process</p>

<p>When an application starts the sub-process, no arguments are passed.  The parent process must provide its own facilities to terminate the sub process.  Ideally, the sub process would monitor the parent process; however, shortcomings in Java's API prevent it from doing this.</p>

<h1>Concurrency</h1>

<p>Concurrency within a scope is supported because Rhino allows for concurrent execution of Javascript.  The parent process should expose synchronization functionality or enforce synchronization.</p>

<h1>Communication</h1>

<p>Communication between the main process and the sub-process is two-way and non-blocking.  Every time data is transmitted between the parent and subprocess, a single JSON object is sent.  The JSON object contains all data needed to perform the request or handle the response.  If the parent process sends an empty JSON object, {}, it means that the child process should terminate itself.  The basic format of all JSON objects sent is described below:</p>

<ul>
<li>ScopeID:  The scope ID for the request or response.  The IDs are generated by the parent process.  This is always a positive integer.</li>
<li>ThreadID:  Value that identifies the calling thread in the parent process.  This can be any type.  Responses must contain the ThreadID so that the parent process knows which thread to give the returned value.</li>
<li>Data:  Additional data that pertains to the request or response.  The contents depend on the command.</li>
<li>Command:  The command.  Possible commands, (listed as request and response,) are:
<ul>
<li>Compile / RespondCompile</li>
<li>LoadCompiled / RespondLoadCompiled</li>
<li>EvalScope / RespondEvalScope</li>
<li>DisposeScope</li>
<li>CallFunctionInScope / RespondCallFunctionInScope</li>
<li>CallParentFunction / RespondCallParentFunction</li>
<li>CallCallback / RespondCallCallback</li>
</ul>
</li>
</ul>

<p>The commands are described in the next section.</p>

<h1>Commands</h1>

<h2>Compile / RespondCompile</h2>

<p>Compiles a script so it can be run in a scope.  The sub process returns the compiled script so it can be re-used in other sub processes or after re-starting the main server.</p>
<h3>Compile</h3>

<p>Compiles the script.  The compiled script is now available for execution via the EvalScope command.</p>

<p>The data portion of the JSON packet contains the following properties:</p>

<ul>
<li><b>Script</b>:  String that is the Javascript to be compiled.</li>
<li><b>ScriptID</b>:  The ID of the compiled script</li>
</ul>
<h3>RespondCompile</h3>

<p>Returns the results of compiling the script.  If successful, the results can be re-used to load the compiled script without re-compilation in another instance of the JavascriptSubprocess.</p>

<p>The data portion of the JSON packet contains the following properties:</p>

<ul>
<li><b>CompiledScript</b>:  The compiled script.  This can be any valid JSON value.  This can also be null if the compiled script can not be re-used, such is if this API is ported to a library that doesn't re-use pre-compiled Javascript.</li>
<li><b>Exception</b>:  Any exceptions that occurred.</li>
</ul>
<h2>LoadCompiled / RespondLoadCompiled</h2>

<p>Loads a script that was compiled with Compile.  If the parent process is capable of caching compiled scripts, this should be faster then recompiling them all the time.</p>

<h3>LoadCompiled</h3>

<p>The data portion of the JSON packet contains the following properties:</p>

<ul>
<li><b>CompiledScript</b>:  The compiled script.  This must be the JSON value returned by a prior call to Compile.</li>
<li><b>ScriptID</b>:  The ID of the compiled script</li>
</ul>
<h3>RespondLoadCompiled</h3>

<p>The data portion of the JSON packet contains the following properties:</p>

<ul>
<li><b>Exception</b>: Any exceptions that occurred.</li>
</ul>
<h2>EvalScope / RespondEvalScope</h2>




<p>EvalScope is sent by the parent process, and RespondEvalScope is sent by the subprocess. &nbsp;This request/response is used when creating a scope or when running additional Javascript in a scope.</p><h3 style="font-size: 1.1em; font-weight: bold; ">EvalScope</h3><p>Instructs the sub process to evaluate Javascript in a scope. &nbsp;If there is no scope matching the given ScopeID, then a new scope is created to evaluate the Javascript in.</p><p>The data portion of the JSON packet contains the following properties:<br></p><p></p><ul><li><b>Data</b>: &nbsp;Additional data that is placed into the scope. &nbsp;Each named value is placed into the scope under the same name.</li><li><b>Scripts</b>: &nbsp;Array that indicates that Javascript to execute in the scope. &nbsp;If a member is a string, it will be evaled, if a member is an integer, it is treated as the ScriptID of precompiled Javascript and executed.</li><li><b>Functions</b>: &nbsp;Array containing strings, the names of functions that the scope can call. &nbsp;These functions must remain available&nbsp;throughout the life of the scope, unless they are overwritten.</li><li><b>ReturnFunctions</b>: &nbsp;Optional boolean, if true, the response will contain data about the functions in the scope.<br></li><li><b>CacheIDs</b>: &nbsp;Array of values. &nbsp;For each non-null value, the result of executing the corresponding script will be cached for re-use for returning from later calls into the parent process.</li></ul><p></p><h3 style="font-size: 1.1em; font-weight: bold; ">RespondEvalScope</h3><p>Informs the parent process that evaluating Javascript in a scope is complete. &nbsp;Returns the results of the evaluation serialized as JSON. &nbsp;Depending on parameters passed to EvalScope, additional data might be returned.</p><p>The data portion of the JSON packet contains the following properties:</p><ul><li><b>Results</b>: &nbsp;Array of results, the index of each result corresponds with the index of the requested script. &nbsp;If an exception&nbsp;occurred, this array might be incomplete.</li><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.<br></li><li><b>Functions</b>: &nbsp;Only present if ReturnFunctions is true. &nbsp;Javascript object with properties that have the same name as every function in the scope. &nbsp;Each property is an object with the following properties:</li><ul><li><b>Properties</b>: &nbsp; All of the values that are assigned to the function.</li><li><b>Arguments</b>: &nbsp;Ordered array of arguments.</li></ul></ul>Regarding "Functions", if EvalScope is called with ReturnFunctions set to true, then based on the following Javascript...<p></p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre>foo.a = "gdfssddfsa";
foo.b = "arafraes";
function foo() { ..... }

bar.a="jdydy";
bar.b="vzvz";
function bar() { .... }

123;</pre></blockquote><p>... The following result is returned in the "Data" portion:</p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre>{
   "Result": 123,
   "Functions":
   {
      "foo": {"a": "gdfssddfsa", "b": "arafraes"},
      "bar": {"a": "jdydy", "b": "vzvz"}
   }
}</pre></blockquote><p></p><h2><span class="Apple-style-span" style="font-weight: normal; font-size: medium; "><b><h2 style="display: inline !important; "><b><b><h2 style="display: inline !important; "><font class="Apple-style-span" size="6"><span class="Apple-style-span" style="font-size: 20px;">CallFunctionInScope / RespondCallFunctionInScope</span></font></h2></b></b></h2></b></span><br></h2><h2><b><p></p></b></h2><p><span class="Apple-style-span" style="font-weight: normal;">CallFuncionInScope is sent by the parent process, and RespondCallFunctionInScope is sent by the child process.<br></span></p><h3><b><p style="display: inline !important; "></p><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">CallFunctionInScope</span></font></h3></b><p></p></b></h3><p><span class="Apple-style-span" style="font-weight: normal;">Calls a function in the specified scope.</span></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><p></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>FunctionName</b>: &nbsp;The name of the function being called.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Arguments</b>: &nbsp;Array of arguments.</span></li></ul><h3><b><p style="display: inline !important; "></p><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">RespondCallFunctionInScope</span></font></h3></b><p></p></b></h3><p><span class="Apple-style-span" style="font-weight: normal;">Returns the results of calling a function in a scope.</span></p><p></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>Result</b>: &nbsp;Result of eval, serialized as JSON.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.<br></span></li></ul><p></p><p></p><h2><b><p style="display: inline !important; "></p><b><h2 style="display: inline !important; "><font class="Apple-style-span" size="6"><span class="Apple-style-span" style="font-size: 20px;">DisposeScope</span></font></h2></b><p></p></b></h2><p><span class="Apple-style-span" style="font-weight: normal;">Informs the subprocess that a scope with a given ScopeID is no longer needed by the parent process. &nbsp;The subprocess is free to dispose the scope, make it&nbsp;eligible&nbsp;for garbage collection, reclaim the memory, ect, ect. &nbsp; Calling DisposeScope while there are ongoing function calls in the specified scope is undefined, and the parent process should ensure that all pending function calls are complete before calling DisposeScope.</span></p><p><span class="Apple-style-span" style="font-weight: normal;">The subprocess does not respond to DisposeScope. &nbsp;It is assumed that the ScopeID is free for reuse once it reads the next incoming call from the parent process.</span></p><h2><b><p style="display: inline !important; "></p><b><h2 style="display: inline !important; "><font class="Apple-style-span" size="6"><span class="Apple-style-span" style="font-size: 20px;">CallParentFunction / RespondCallParentFunction</span></font></h2></b><p></p></b></h2><p><span class="Apple-style-span" style="font-weight: normal;">CallParentFunction is sent by the subprocess, and RespondCallParentFunction is sent by the parent process.</span></p><h3><b><h2 style="display: inline !important; "><b><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">CallParentFunction</span></font></h3></b></b></h2></b><br></h3><h2><b><p></p></b></h2><p><span class="Apple-style-span" style="font-weight: normal;">Calls a function in the parent process. &nbsp;When CallParentFunction is called, the ThreadID passed by the subprocess is the same as the ThreadID passed into the originating CallFunctionInScope, EvalScope, or CallCallback. &nbsp;The implication is that a parent process will use the same thread when the call stack goes back and forth multiple times between both the parent and sub processes.</span></p><p><span class="Apple-style-span" style="font-weight: normal;">CallParentFunction introduces a complexity when passing callbacks to the parent process. &nbsp;In this case, a special convention is used. &nbsp;This convention is described below.</span></p><p></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><p></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>FunctionName</b>: &nbsp;The name of the function being called.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Arguments</b>: &nbsp;Array of arguments.</span></li></ul><span class="Apple-style-span" style="font-weight: normal;">In the arguments array, if any value is a callback, it is represented as a JSON object with two properties, as follows:</span><p></p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre><span class="Apple-style-span" style="font-weight: normal;">{"Callback": true, "CallbackId": (any valid JSON value)}</span></pre></blockquote><p><span class="Apple-style-span" style="font-weight: normal;">The parent process must use its own internal context to differentiate between callbacks and similar-looking objects.</span></p><h3><b><p style="display: inline !important; "></p><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">RespondCallParentFunction</span></font></h3></b><p></p></b></h3><div><p><span class="Apple-style-span" style="font-weight: normal;">Returns the results of calling a function in the parent process.</span></p><p></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>Result</b>: &nbsp;Result of calling the function in the parent process.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Eval</b>: &nbsp;Javascript to eval and return. &nbsp;If this is a string, it will be evaled. &nbsp;If this is a number, it is considered to be the ScriptID of precompiled Javascript. &nbsp;If this value is present, Result and Exception will be missing.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>CacheID</b>: &nbsp;If this is the only present value, then the object with the given CacheID is returned. &nbsp;If this value is present with Result, then Result is cached. &nbsp;If this value is present with Eval, then the result of running Eval is cached.</span></li></ul><p><span class="Apple-style-span" style="font-weight: normal;">Note: &nbsp;The parent process may include additional data in the exception object so that, if the calling Javascript does not handle the exception and merely passes it back to the parent, the parent can re-throw the appropriate exception up its call stack.</span></p></div><h2><b><p style="display: inline !important; "></p><b><h2 style="display: inline !important; "><font class="Apple-style-span" size="6"><span class="Apple-style-span" style="font-size: 20px;">CallCallback / RespondCallCallback</span></font></h2></b><p></p></b></h2><p></p><p></p><p><span class="Apple-style-span" style="font-weight: normal;">CallCallback is sent by the parent process, and RespondCallCallback is sent by the child process.<br></span></p><h3><b><p style="display: inline !important; "></p><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">CallCallback</span></font></h3></b><p></p></b></h3><p><span class="Apple-style-span" style="font-weight: normal;">Calls a callback in the specified scope.</span></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><p></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>CallbackId</b>: &nbsp;The Id of the callback function being called. &nbsp;This can be any value.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Arguments</b>: &nbsp;Array of arguments.</span></li></ul><h3><b><p style="display: inline !important; "></p><b><h3 style="display: inline !important; "><font class="Apple-style-span" size="5"><span class="Apple-style-span" style="font-size: 18px;">RespondCallCallback</span></font></h3></b><p></p></b></h3><p><span class="Apple-style-span" style="font-weight: normal;">Returns the results of calling a callback in a scope.</span></p><p></p><p><span class="Apple-style-span" style="font-weight: normal;">The data portion of the JSON packet contains the following properties:</span></p><ul><li><span class="Apple-style-span" style="font-weight: normal;"><b>Result</b>: &nbsp;Result of eval, serialized as JSON.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</span></li><li><span class="Apple-style-span" style="font-weight: normal;"><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.</span></li></ul>