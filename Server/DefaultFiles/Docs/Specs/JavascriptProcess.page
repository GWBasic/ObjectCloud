<div>Javascript Sub-Process</div><meta charset="utf-8"><h1 style="font-size: 1.5em; font-weight: bold; ">Overview</h1><p>There are many Javascript libraries like Spidermonkey, Rhino and Google's V8 that allow an application designer to incorporate lightweight user-generated programs. &nbsp;These libraries allow the programmer to expose functionality in a rather secure manner; as the programmer can deterministically expose a limited set of well-known functions for user-generated code to use. &nbsp;A limitation in these libraries is that they aren't universally supported in different platforms. &nbsp;Specifically, Rhino is only callable from Java, and Google's V8 is only callable from C++. &nbsp;This can sometimes severely limit an application designer's choice in finding a robust Javascript library. &nbsp;This is the case for ObjectCloud, where there are no well-supported Javascript interpeters for .Net.</p><p>This document describes how ObjectCloud communicates with Javascript environments running in a sub-process. &nbsp;Initially, to keep development, building, and deployment simple, the sub-process will be a Java sub-process using Rhino as a Javascript engine. &nbsp;In the long term, a sub-process written in C++ using Google's V8 as a Javascript engine will implement the same communication protocol described here. &nbsp;While "heavier" then hosting an interpreter as an in-process library; a multi-process&nbsp;architecture&nbsp;has robustness and security benefits. &nbsp;These are seen in Google Chrome where a misbehaving sub-process, when killed, allows other pages to remain open.</p><h2 style="font-size: 1.25em; font-weight: bold; ">Need and Justification</h2><p>There are two reasons why ObjectCloud needs to run server-side Javascript in a sub-process instead of within its own process. &nbsp;These are as follows:<br></p><p></p><ol><li><b>Stability</b>: &nbsp;Poorly-written Javascript could crash ObjectCloud's process, or could hog CPU resources causing poor performance. &nbsp;Such performance issues could impact all users of the server. &nbsp;A real risk is that, while developing, a programmer accidentally introduces an&nbsp;infinite&nbsp;loop into server-side Javascript. &nbsp;Another risk is that server-side Javascript could call an API that blocks in native platform calls. &nbsp;In both situations, .Net's Thread.Abort() is not&nbsp;guaranteed&nbsp;to stop misbehaving Javascript. &nbsp;In contrast; ObjectCloud can kill misbehaving sub-processes. &nbsp;Thus, ObjectCloud must use a multi-process design for server-side Javascript.</li><li><b>.Net's Limitations</b>: &nbsp;No good Javascript interpreters exist for .Net. &nbsp;This is because .Net can not garbage collect executable code once it is loaded into RAM. &nbsp;In Javascript, functions are treated like data, thus Javascript can only run well in environments that allow garbage collection of code. &nbsp;This limitation can be worked around by interpreting Javascript, but it is not a long-term solution as it will always be much slower then solutions like V8 that convert Javascript to true machine code.</li></ol>The early ObjectCloud prototype converted Rhino, a Java Javascript interpreter, into a .Net dll, but this proved to be too slow and unstable for ObjectCloud applications that made heavy use of server-side Javascript. &nbsp;Work was also performed with Jint, a true Javascript interpreter for .Net; although Jint was too buggy and introduced too many .Net semantics into Javascript to meet ObjectCloud's needs. &nbsp;As a result of work with Rhino converted to a .Net dll, and Jint, the conclusion is that the only way for ObjectCloud to reliably handle server-side Javascript is to run it in sub-processes written in languages that provide better Javascript support.<br><p></p><h2 style="font-size: 1.25em; font-weight: bold; ">Implementation&nbsp;Decisions</h2><p>The obvious best choice for a Javascript sub-process is a natively-compiled executable that uses Google's V8 Javascript engine. &nbsp;This would&nbsp;yield&nbsp;the fastest Javascript possible; although it introduces some&nbsp;compromises&nbsp;in ObjectCloud's development philosophies:</p><p></p><ul><li>At this point, there are no standard V8 libraries commonly found on Windows, Mac, and Linux. &nbsp;(In contrast, SQLite has standard libraries on all three.) &nbsp;V8, and thus the executable, would need to be specially-compiled for each target platform. &nbsp;Currently ObjectCloud runs on Windows, Mac, and Linux without any recompilation, as it is Andrew's philosophy that ObjectCloud should require as little as possible "work" to set up ObjectCloud anywhere.</li><li>C++ tends to have more complicated build issues compared against C# and Java. &nbsp;One of Andrew's philosophies is to avoid things like make and stick with build environments that work in common IDEs.</li></ul>Thus, the Javascript sub-process is written in such a way that it can run anywhere without platform-specific compilation; although the protocol between the parent ObjectCloud process and Javascript subprocess utilizes standard and well-defined techniques. &nbsp;This allows a V8 subprocess to be swapped in once time can be allocated to deal with C++ development and portability complexities.<br><p></p><p>For now, the Javascript subprocess is written in Java and uses Rhino. &nbsp;This minimizes the development learning curve as it utilizes lessons learned from converting Rhino into a .Net dll. &nbsp;Communication between the parent and child processes will use stdin and stdout. &nbsp;This minimizes relying on sockets, as sockets can sometimes "fill up" on certain operation systems. &nbsp;It also&nbsp;alleviates&nbsp;depending on platform-specific IPC systems, like named pipes.</p><p>As stated earlier, the current implementation is a works-anywhere approach. &nbsp;In the long-term, because the protocol is well-documented and universally available on all platforms, the Java and Rhino sub-process can be replaced with a V8 subprocess. &nbsp;Another option is to use Node.js as a subprocess, however, that will require that Node.js gets good support on Windows, Mac, and Linux, and that Node.js allows true isolation with multiple contexts. &nbsp;Its current implementation of evalcx() would mean that Javascript could pollute Node's parent global scope, which could then contaminate other scopes and the lower-level IO subsystem.</p><h2 style="font-size: 1.25em; font-weight: bold; ">Capability and Behavior</h2><p>All communication between the parent and sub process occurs on the sub process's stdin and stdout using JSON. &nbsp;The subproces supports a single parent scope that declares runtime code, and multiple isolated child scopes that use the parent scope's code.&nbsp;&nbsp;All&nbsp;communication&nbsp;should be treated as non-blocking; that is, the parent process can call many functions in different scopes concurrently. &nbsp;In general, the following activities are supported:</p><p></p><ul><li>Parent process creates the initial parent scope when the sub process is created. &nbsp;The subprocess returns metadata about the parent scope, including functions, through stdout.</li><li>Parent process calls a function in a child scope. &nbsp;The subprocess returns the function's results through stdout. &nbsp;(In order to minimize overhead from communication between the parent and child processes, child scopes are created on demand.)</li><li>Parent process disposes a child scope.</li><li>Subprocess calls a function that the parent process placed into the parent scope through stdout. &nbsp;The parent process returns the results through stdin.</li><li>Parent process calls a callback function that was passed when the subprocess called one of its functions. &nbsp;The subprocess returns the results &nbsp;through stdout.</li></ul>Communication is described in detail in the Communication section. &nbsp;Right now, the parent process can not hold references to objects that are passed to its functions beyond the lifetime of a function call. &nbsp;This means that the parent process can not use callbacks for&nbsp;asynchronous&nbsp;communication and must call callbacks during a function call and not afterwards.<p></p><p><span class="Apple-style-span" style="font-size: 24px; font-weight: bold; ">Creating a Javascript Sub-Process</span><br></p><p>When an application starts the sub-process, no arguments are passed. &nbsp;The parent process must provide its own facilities to terminate the sub process. &nbsp;Ideally, the sub process would monitor the parent process; however, shortcomings in Java's API prevent it from doing this.</p><p></p><h1 style="font-size: 1.5em; font-weight: bold; ">Communication</h1><p>The initial communication between the parent and sub process creates the parent scope which contains code for all child scopes.&nbsp;</p><p>After the parent scope is created, communication between the main process and the sub-process is two-way and non-blocking.</p><p></p><p>The commands are described in the next section.</p><h1 style="font-size: 1.5em; font-weight: bold; ">Concurrency</h1><p>Concurrency within a scope is not supported, although the child processes do not need to enforce concurrency. &nbsp;The parent process should ensure that it does not execute multiple evals or functions within the same scope concurrently.</p><p>Concurrency is supported among different scopes; that is multiple concurrent evals and/or function calls are supported, as long as each call or eval is in a different scope.</p><h1 style="font-size: 1.5em; font-weight: bold; ">Creating the Parent Scope</h1><p>Initially, the first JSON command sent to the sub process contains Javascript to establish the parent scope. &nbsp;This initial JSON object contains the following properties:<br></p><p></p><ul><li><b>Scripts</b>: &nbsp;Array of strings that contain the Javascript that is executed to create the scope. &nbsp;Each string is evaled in the order in the array.</li><li><b>Functions</b>: &nbsp;Array containing strings, the names of functions that the scope can call in the parent process.</li></ul><p>The sub process will compile all of the passed in scripts in the parent scope. &nbsp;If compilation is successful, an empty JSON object will be returned. &nbsp;If compilation fails, then a JSON object is returned with the following properties:</p><div><p></p><p></p><ul><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred. &nbsp;If there is an exception, the process will end.<br></li></ul><span class="Apple-style-span" style="font-size: 24px; font-weight: bold; ">Commands</span><br><p>After the parent scope is created, the following commands are used.&nbsp;&nbsp;Every time data is transmitted between the parent and subprocess, a single JSON object is sent. &nbsp;The JSON object contains all data needed to perform the request or handle the response. &nbsp;If the parent process sends an empty JSON object, {}, it means that the child process should terminate itself. &nbsp;The basic format of all JSON objects sent is described below:</p><p></p><ul><li><b>ScopeID</b>: &nbsp;The scope ID for the request or response. &nbsp;The IDs are generated by the parent process. &nbsp;This is always a positive integer.</li><li><b>ThreadID</b>: &nbsp;Value that identifies the calling thread in the parent process. &nbsp;This can be any type. &nbsp;Responses must contain the ThreadID so that the parent process knows which thread to give the returned value.</li><li><b>Data</b>: &nbsp;Additional data that pertains to the request or response. &nbsp;The contents depend on the command.</li><li><b>Command</b>: &nbsp;The command. &nbsp;Possible commands, (listed as request and response,) are:</li><ul><li>CreateScope /&nbsp;RespondCreateScope</li><li>DisposeScope</li><li>CallFunctionInScope / RespondCallFunctionInScope</li><li>CallParentFunction / RespondCallParentFunction</li><li>CallCallback / RespondCallCallback</li></ul></ul><p></p><h2 style="font-size: 1.25em; font-weight: bold; ">CreateScope /&nbsp;RespondCreateScope<br></h2><p>CreateScope is sent by the parent process, and CreateEvalScope is sent by the subprocess. &nbsp;This request/response is used when creating a child scope.</p><h3 style="font-size: 1.1em; font-weight: bold; ">CreateScope</h3><p>Instructs the sub process to create a scope.</p><p>The data portion of the JSON packet contains values that will be assigned to the child scope. &nbsp;For example, if the data portion has two properties, A and B, then the A and B properties will be placed into the newly-created scope.</p><p></p><h3 style="font-size: 1.1em; font-weight: bold; ">RespondCreateScope</h3><p>Informs the parent process that creating a Javascript scope is complete. &nbsp;Returns the results of the creation serialized as JSON.</p><p>The data portion of the JSON packet contains the following properties:</p><ul><li><b>Result</b>: &nbsp;Result of evaluating the last script used to create the scope, serialized as JSON. &nbsp;If the result is undefined, then this value will be missing.</li><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred. &nbsp;If there is an exception, then no Result is missing.<br></li><li><b>Functions</b>: &nbsp;Javascript object with properties that have the same name as every function in the scope. &nbsp;Each property is an object with the following properties:</li><ul><li><b>Properties</b>: &nbsp; All of the values that are assigned to the function.</li><li><b>Arguments</b>: &nbsp;Ordered array of arguments.</li></ul></ul>Regarding "Functions", if EvalScope is called with ReturnFunctions set to true, then based on the following Javascript...<p></p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre>foo.a = "gdfssddfsa";
foo.b = "arafraes";
function foo() { ..... }

bar.a="jdydy";
bar.b="vzvz";
function bar() { .... }

123;</pre></blockquote><p>... The following result is returned in the "Data" portion:</p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre>{
   "Result": 123,
   "Functions":
   {
      "foo": {"a": "gdfssddfsa", "b": "arafraes"},
      "bar": {"a": "jdydy", "b": "vzvz"}
   }
}</pre></blockquote><h2 style="font-size: 1.25em; font-weight: bold; ">CallFunctionInScope / RespondCallFunctionInScope<br></h2><p>CallFuncionInScope is sent by the parent process, and RespondCallFunctionInScope is sent by the child process.<br></p><h3 style="font-size: 1.1em; font-weight: bold; ">CallFunctionInScope</h3><p>Calls a function in the specified scope.</p><p>The data portion of the JSON packet contains the following properties:</p><p></p><ul><li><b>FunctionName</b>: &nbsp;The name of the function being called.</li><li><b>Arguments</b>: &nbsp;Array of arguments.</li></ul><h3 style="font-size: 1.1em; font-weight: bold; ">RespondCallFunctionInScope</h3><p>Returns the results of calling a function in a scope.</p><p></p><p>The data portion of the JSON packet contains the following properties:</p><ul><li><b>Result</b>: &nbsp;Result of eval, serialized as JSON.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</li><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.<br></li></ul><p></p><p></p><h2 style="font-size: 1.25em; font-weight: bold; ">DisposeScope<br></h2><p>Informs the subprocess that a scope with a given ScopeID is no longer needed by the parent process. &nbsp;The subprocess is free to dispose the scope, make it&nbsp;eligible&nbsp;for garbage collection, reclaim the memory, ect, ect. &nbsp; Calling DisposeScope while there are ongoing function calls in the specified scope is undefined, and the parent process should ensure that all pending function calls are complete before calling DisposeScope.</p><p>The subprocess does not respond to DisposeScope. &nbsp;It is assumed that the ScopeID is free for reuse once it reads the next incoming call from the parent process.</p><h2 style="font-size: 1.25em; font-weight: bold; ">CallParentFunction / RespondCallParentFunction<br></h2><p>CallParentFunction is sent by the subprocess, and RespondCallParentFunction is sent by the parent process.</p><h3 style="font-size: 1.1em; font-weight: bold; ">CallParentFunction</h3><p>Calls a function in the parent process. &nbsp;When CallParentFunction is called, the ThreadID passed by the subprocess is the same as the ThreadID passed into the originating CallFunctionInScope, EvalScope, or CallCallback. &nbsp;The implication is that a parent process will use the same thread when the call stack goes back and forth multiple times between both the parent and sub processes.</p><p>CallParentFunction introduces a complexity when passing callbacks to the parent process. &nbsp;In this case, a special convention is used. &nbsp;This convention is described below.</p><p></p><p>The data portion of the JSON packet contains the following properties:</p><p></p><ul><li><b>FunctionName</b>: &nbsp;The name of the function being called.</li><li><b>Arguments</b>: &nbsp;Array of arguments.</li></ul>In the arguments array, if any value is a callback, it is represented as a JSON object with two properties, as follows:<p></p><blockquote class="webkit-indent-blockquote" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 40px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; "><pre>{"Callback": true, "CallbackId": (any valid JSON value)}</pre></blockquote><p>The parent process must use its own internal context to differentiate between callbacks and similar-looking objects.</p><h3 style="font-size: 1.1em; font-weight: bold; ">RespondCallParentFunction</h3><div><p>Returns the results of calling a function in the parent process.</p><p></p><p>The data portion of the JSON packet contains the following properties:</p><ul><li><b>Result</b>: &nbsp;Result of calling the function in the parent process.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</li><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.</li><li><b>Eval</b>: &nbsp;Javascript to eval and return. &nbsp;If this value is present, Result and Exception will be missing.</li><li><b>CacheID</b>: &nbsp;If this is the only present value, then the object with the given CacheID is returned. &nbsp;If this value is present with Result, then Result is cached. &nbsp;If this value is present with Eval, then the result of running Eval is cached.</li></ul><p>Note: &nbsp;The parent process may include additional data in the exception object so that, if the calling Javascript does not handle the exception and merely passes it back to the parent, the parent can re-throw the appropriate exception up its call stack.</p></div><h2 style="font-size: 1.25em; font-weight: bold; ">CallCallback / RespondCallCallback<br></h2><p></p><p></p><p>CallCallback is sent by the parent process, and RespondCallCallback is sent by the child process.<br></p><h3 style="font-size: 1.1em; font-weight: bold; ">CallCallback</h3><p>Calls a callback in the specified scope.</p><p>The data portion of the JSON packet contains the following properties:</p><p></p><ul><li><b>CallbackId</b>: &nbsp;The Id of the callback function being called. &nbsp;This can be any value.</li><li><b>Arguments</b>: &nbsp;Array of arguments.</li></ul><h3 style="font-size: 1.1em; font-weight: bold; ">RespondCallCallback</h3><p>Returns the results of calling a callback in a scope.</p><p></p><p>The data portion of the JSON packet contains the following properties:</p><ul><li><b>Result</b>: &nbsp;Result of eval, serialized as JSON.&nbsp;&nbsp;If the result is undefined, then this value will be missing.</li><li><b>Exception</b>: &nbsp;JSON-serialized exception, if it&nbsp;occurred.</li></ul></div>