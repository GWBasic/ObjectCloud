<div>Particle draft 2</div>Particle is a system for collaborative
messaging and notification of changes to objects.  A subset of the
particle system includes collaborative, actively synchronized
documents.

<p style="margin-bottom: 0in;">The Particle System is designed to
address the following technical needs:</p>
<ul><li><p style="margin-bottom: 0in;"><b>Merging of chat and email V2</b>:
	 The particle system is designed to allow email documents and chat
	to flow seamlessly into each other.  Instead of replying to an
	email, replies are typed in-line and the original author is notified
	that the document is updated.</p>
	</li><li><p style="margin-bottom: 0in;"><b>Spam Control:</b></p>
	</li><li><p style="margin-bottom: 0in;"><b>Security</b>:  The “spoofing”
	problem common to email is designed out of the protocol.</p>
	</li><li><p style="margin-bottom: 0in;"><b>Barrier to entry</b>:  Servers
	can optionally choose to require that other servers have a signed
	SSL certificate for their domain.  This creates a minor economic
	barrier to spam, and increases a message's origin's traceability.</p>
	</li><li><p style="margin-bottom: 0in;"><b>Standard way for clients to
	block senders and domains</b></p>
	</li><li><p style="margin-bottom: 0in;"><b>Ease of federation:</b><span style="font-weight: normal;">
	 Particle uses RESTful APIs, which are easier to work with and
	almost universally supported in all programming languages</span></p>
	</li><li><p style="margin-bottom: 0in;"><b>Federation out-of-the-box</b><span style="font-weight: normal;">:
	 A sample federated server / client will be provided that works.</span></p>
	</li><li><p style="margin-bottom: 0in;"><b>OpenID integration</b><span style="font-weight: normal;">:
	 Particle is designed to work with OpenID accounts.  A particle user
	is an OpenID user.</span></p>
</li></ul>

<h1 class="western" style="font-weight: normal;">Overview of the
notification protocol</h1>

<p style="margin-bottom: 0in; font-weight: normal;">(Note:  The
notification protocol does not send changes to collaborative
documents.  These are handled later.)</p>

<p style="margin-bottom: 0in; font-weight: normal;">In all cases, a
sender or a client discover the particle endpoints in a manner
similar to OpenID.  The OpenID uri will contain a link tag.</p>

<p style="margin-bottom: 0in; font-weight: normal;">The protocol has
two stages between a sender and recipient:</p>
<ul><li><p style="margin-bottom: 0in; font-weight: normal;">Establishing
	trust between a sender and a recipient</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Sending
	notifications from a sender to a recipient</p>
</li></ul>

<p style="margin-bottom: 0in; font-weight: normal;">The protocol also
has the following stages between a client and the server:</p>
<ul><li><p style="margin-bottom: 0in; font-weight: normal;">Establishing
	a session between a client and a server</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Receiving new
	notifications since a particular date</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Update the
	state of a notification to the following:</p>
	<ul><li><p style="margin-bottom: 0in; font-weight: normal;">read</p>
		</li><li><p style="margin-bottom: 0in; font-weight: normal;">unread</p>
	</li></ul>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Update an
	object's state to:</p>
	<ul><li><p style="margin-bottom: 0in; font-weight: normal;">Ignore  (All
		new notifications to a given object / url are hidden)</p>
		</li><li><p style="margin-bottom: 0in; font-weight: normal;">Unignore 
		(All new notifications to a given object / url are displayed.)</p>
		</li><li><p style="margin-bottom: 0in; font-weight: normal;">Delete (All
		notifications to a given object / url are ignored and currently
		saved ones are deleted.  The sender is asked to discontinue sending
		notifications.)</p>
		</li><li><p style="margin-bottom: 0in; font-weight: normal;">SilentDelete
		(Same as delete except that the sender isn't asked to discontinue
		sending notifications.)</p>
	</li></ul>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Block sender
	or domain</p>
</li></ul>

<p style="margin-bottom: 0in; font-weight: normal;">Some
implementations may optionally allow a change from SilentDelete to
Unignore.</p>
<h1 class="western" style="font-weight: normal;">Discovering the
Particle Endpoint:</h1>
<p style="margin-bottom: 0in; font-weight: normal;">Discovering the
particle endpoint is performed in a manner similar to OpenID:</p>
<ol><li><p style="margin-bottom: 0in; font-weight: normal;">Download the
	HTML document at the recipient's openID uri</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Scan the
	&lt;title&gt; section for &lt;link&gt; tags</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">All link tags
	where the rel=”particle.” are Particle endpoints.</p>
</li></ol>

<p style="margin-bottom: 0in; font-weight: normal;">Particle endpoints
can be cached as a means of conserving resources.  It is recommended
that cached endpoints expire after a reasonable time, such as after a
4 or 24-hour window.</p>

<p style="margin-bottom: 0in; font-weight: normal;">Example:</p>

<p style="margin-bottom: 0in;"><span style="font-weight: normal;">for
the OpenID <a href="http://objectcloud.com/Users/GWBasic.user">http://objectcloud.com/Users/GWBasic.user</a>:</span></p>

<p style="margin-bottom: 0in;"><span style="font-weight: normal;">Downloading
<a href="http://objectcloud.com/Users/GWBasic.user">http://objectcloud.com/Users/GWBasic.user</a>
yields:</span></p>

<pre style="margin-bottom: 0in; font-weight: normal; margin-left: 40px;">&lt;html&gt;&lt;head&gt;</pre>
<pre style="margin-bottom: 0in; font-weight: normal; margin-left: 40px;">…</pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.establishTrust”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.respondTrust”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=respondTrust</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.receiveNotification”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=receiveNotification</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.establishSession”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=establishSession</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.getNotifications”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=getNotifications</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.updateNotificationState”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=updateNotificationState</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.updateObjectState”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=updateObjectState</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.block”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=block</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.unBlock”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=unBlock</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; margin-left: 40px;">   <span style="font-weight: normal;">&lt;link
rel=”particle.sendNotification”
href=”<a href="http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust">https://objectcloud/Users/GWBasic/part.icle?Method=sendNotification</a>”
/&gt;</span></pre>
<pre style="margin-bottom: 0in; font-weight: normal; margin-left: 40px;">   …</pre>

<p style="margin-bottom: 0in; font-weight: normal;">All endpoints
utilize urlencoded POST requests.  Argument names are case-sensitive.</p>
<h1 class="western" style="font-weight: normal;">Establishing Trust</h1>
<p style="font-weight: normal;">In order to prevent the spoofing
problem that is common in email, trust must be established between a
sender and a recipient.  The trust relationship establishes the
following facts:</p>
<ul><li><p style="font-weight: normal;">That the sender is who it says it
	is</p>
	</li><li><p style="font-weight: normal;">(Optional) That the sender has a
	registered and signed domain</p>
</li></ul>
<p style="font-weight: normal;">Production systems are strongly
encouraged to enable SSL and only accept notifications from
SSL-signed domains.  This creates a financial barrier to SPAMmers
that is nominal for legitimate entities.</p>
<ol><li><p style="font-weight: normal;">The sender sends a POST request
	to the recipient's particle.establishTrust endpoint.  It has two
	arguments:</p>
</li></ol>
<ol><li><p><b>sender</b><span style="font-weight: normal;">:  The
	sender's OpenID</span></p>
	</li><li><p><b>token</b><span style="font-weight: normal;">:  A token to
	send back to the sender in order to establish trust.  This is a
	string of any length.</span></p>
</li></ol>
<ol start="2"><li><p style="font-weight: normal;">While the sender's request is
	open, the recipient sends a POST request to the sender's
	particle.respondTrust endpoint.  It has two arguments:</p>
</li></ol>
<ol><li><p><b>token</b><span style="font-weight: normal;">:  The token
	sent from the originating particle.establishTrust call</span></p>
	</li><li><p><b>senderToken</b><span style="font-weight: normal;">:  A
	string generated by the recipient that it uses to identify the
	sender.  This can contain any character, and can be a maximum of 200
	characters.</span></p>
</li></ol>
<ol start="3"><li><p style="font-weight: normal;">The sender responds to the
	particle.respondTrust request with either a 202 (accepted) status
	code if the senderToken was established correctly, or a 4xx error
	code to indicate an error.</p>
	</li><li><p style="font-weight: normal;">The recipient responds to the
	particle.establishTrust with either a 201 (Created) or a 4xx error
	code to indicate an error.</p>
</li></ol>
<p style="font-weight: normal;">Notes:</p>
<p style="font-weight: normal;">The recipient and sender will store
the senderToken in their own internal databases.  When sending
notifications, the senderToken is sent as a means of identifying who
the sender is.  The recipient can require that the sender obtain a
new senderToken at any time.</p>
<p style="font-weight: normal;">The requests described are
synchronous, that is, the sender does not return from the
particle.establishTrust request until after the particle.respondTrust
is complete.</p>
<p style="font-weight: normal;">The token and senderToken can contain
any string value.  It is recommended that clients utilize algorithms
that ensure that these strings are sufficiently random and hard to
guess.</p>
<p style="font-weight: normal;">The sender should delete token during
the call to particle.respondTrust to prevent security violations.</p>
<p style="font-weight: normal;">SenderTokens are one-way. 
Specifically, if the token that Jack uses when sending notifications
to Jill is different then what Jill uses to send notifications to
Jack.</p>
<h1 class="western" style="font-weight: normal;">Receiving a
Notification</h1><h2>Downloading Existing Notifications<br></h2>
<p style="font-weight: normal;">When a server sends a notification to
another server, the sender uses particle.receiveNotification
endpoint.  In order to identify itself, the sender uses the
senderToken that it obtained when it established trust.  The sender
must be prepared to re-establish trust at any time.</p>
<ol><li><p class="numbering-1-western" style="font-weight: normal;">The
	sender sends a POST request to the particle.receiveNotification
	endpoint.  The following urlencoded arguments are present:</p>
	<ol><li><p class="numbering-1-western"><b>senderToken</b><span style="font-weight: normal;">:
		 This is the senderToken established during the calls to
		particle.establishTrust and particle.respondTrust.  It identifies
		the sender and prohibits spoofing</span></p>
		</li><li><p class="numbering-1-western"><b>objectUrl</b><span style="font-weight: normal;">:
		 The URL to the document.  Displaying this URL in an iFrame should
		always work on simpler clients.  This value should never change,
		and is considered the object's unique ID.</span></p>
		</li><li><p class="numbering-1-western"><b>title</b><span style="font-weight: normal;">:
		 The title of the document.  This is always the newest version of
		the target object's title, and can change between notifications.</span></p>
		</li><li><p class="numbering-1-western"><b>documentType</b><span style="font-weight: normal;">:
		 The document type.  Some particle clients might be able to provide
		enhanced capabilities for known document types.  For unknown
		document types, the url will be displayed in an iFrame.</span></p>
		</li><li><p class="numbering-1-western"><b>messageSummary</b><span style="font-weight: normal;">:
		 A summary of the notification that will be displayed to the
		recipient.  The recommended convention is to limit this to 80
		characters.  Examples include:</span></p>
	</li></ol>
</li></ol>
<ul><ul><ul><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			shared a document with you</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			updated the document</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			added you to the conversation</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			said: “...”</p>
		</li></ul></ul></ul>
<ol><ol><li><p class="numbering-1-western"><b>changeData</b><span style="font-weight: normal;">:
		 Additional data that describes the change.  This is only utilized
		if the client recognizes the documentType.  The specific format of
		changeData is defined by the documentType.  JSON is recommended,
		although any string-based encoding will work.</span></p>
	</li></ol><li><p class="numbering-1-western" style="font-weight: normal;">If
	the senderToken is unknown or trust needs to be re-established, then
	recipient responds with a 412 (precondition failed.) and the text
	“senderToken”.  The sender should use the
	provider.establishTrust endpoint to get a new senderToken, and then
	re-send the notification.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">If
	the notification was sent successfully, then the recipient responds
	with a 202 (accepted).</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">The
	error code 450 (Blocked) is used to indicate that the sender should
	stop sending new notifications for the objectUrl.  Recipients should
	have additional logic to handle cases where this error code is
	ignored.  Recipients may choose not to send this and continue to
	ignore notifications to deleted objects.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">Some
	documentTypes might have additional error codes that need to be
	returned to the object initiating the notification.  These are not
	part of Particle's notification protocol.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">The
	recipient should block any notifications for objects that do not
	come from the same server as the sender.  If this happens, then the
	server will return a 406 (Not Acceptable.)  The server can also
	optionally return a note explaining the error; however, this is
	optional.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">The
	recipient will unblock any clients that have pending requests on
	particle.getNotifications waiting for updated notifications.</p>
</li></ol>
<p style="font-weight: normal;">Notes:</p>
<p style="font-weight: normal;">For collaborative documents, the
sender should be the document's owner.  The particle protocol does
not include explicit functionality to indicate which user made a
particular change to a document; thus the sender will always be the
document's owner instead of who made the modification.</p>
<p style="font-weight: normal;">Object creation is implicit; that is,
a recipient becomes aware of an object as soon as it gets a
notification that has the object's objectUrl as an argument. 
Recipients should store the objectUrl of objects that are deleted,
this way they do not become aware of objects again if they continue
to receive unwanted notifications.</p>
<p style="font-weight: normal;">Some databases work better when
“string” columns are fixed length.  The recommended length for
messageSummary is 80 characters.  Senders need to take into
consideration that their messageSummary could be truncated if longer
then 80 characters.</p><h2 style="font-weight: normal;">Waiting for New Notifications with Comet</h2><p>The particle system allows a client to know exactly when a notification arrives.&nbsp; This is accomplished with a layer 3 Queuing and Reliable Comet session.&nbsp; (The Comet Protocol is document at <a target="_blank" title="" href="/Docs/Specs/Comet%20Protocol.page">/Docs/Specs/Comet Protocol.page)</a></p>To wait for incoming notifications, establish a Queuing and Reliable Comet session at the particle.incomingNotificationEvent endpoint.&nbsp; The server will send each notification as it arrives.&nbsp; Notifications are sent as JSON objects using the same format as recieveNotification endpoint, except that all columns are always present.<br><h1 class="western" style="font-weight: normal;">Establishing a
session</h1>
<p style="font-weight: normal;">The particle.establishSession endpoint
is used to allow a client program to establish a session to display
notifications.  This is primarily intended for use with mobile
devices and thick clients.  Web-based clients where the Particle
endpoints reside on the same server as the HTML can use whatever
system they desire for authentication.</p>
<p style="font-weight: normal;">Future modifications to the protocol
might replace this with a more secure means of establishing a
session.</p>
<ol><li><p style="font-weight: normal;">The client program or device
	stores the OpenID and password.</p>
	</li><li><p style="font-weight: normal;">The client program makes a POST
	request to particle.establishSession with the following urlencoded
	argument:</p>
	<ol><li><p><b>password</b><span style="font-weight: normal;">:  The
		password</span></p>
	</li></ol>
	</li><li><p style="font-weight: normal;">The http status code 202
	(accepted) is returned to indicate that the session was created
	successfully.  Any 4xx response indicates some form of error.</p>
</li></ol>
<p style="font-weight: normal;">It is assumed that session will be
maintained through HTTP cookies.  Therefore, the client program or
device should use an HTTP library that can persist session-level
cookies.</p>
<h1 class="western" style="font-weight: normal;">Getting Notifications</h1>
<p style="font-weight: normal;">The particle.getNotifications endpoint
allows any client or device to get all notifications or a subset of
recent notifications.  Prior to using this endpoint, a session must
be established using particle.establishSession or another suitable
technique.</p>
<p style="font-weight: normal;">All notifications have a notification
ID.  This is an unsigned integer.  The first notification has a low
ID, and each subsequent notification received has one value higher. 
Notification IDs should never be skipped and are immutable.  If a
notification is deleted from the database, its ID should never be
re-used.  The lowest ID is implementation-specific.  Due to
deletions, clients should not expect the lowest notificationId to be
0, 1 or some other constant.</p>
<p style="font-weight: normal;">There is no highest value of
notification ID.  Implementations should be designed such that this
ID can become very large.  64-bit unsigned integers are recommended
as a minimum size.</p>
<ol><li><p style="font-weight: normal;">The client sends a GET request to
	the particle.getNotifications endpoint with the following optional
	urlencoded arguments:</p>
	<ol><li><p><b>newestNotificationId</b><span style="font-weight: normal;">:
		 The highest notificationId allowed.</span></p>
		</li><li><p><b>oldestNotificationId</b><span style="font-weight: normal;">:
		 The lowest notificationId allowed.</span></p>
		</li><li><p><b>maxNotifications</b><span style="font-weight: normal;">: 
		The maximum number of notifications that are to be returned.  Older
		notifications are filtered out if needed.</span></p>
		</li><li><p><b>objectUrl</b><span style="font-weight: normal;">:  If
		present, only notifications for the given objectUrl are returned.</span></p>
		</li><li><p><b>sender</b><span style="font-weight: normal;">:  The
		sender's OpenId.  If present, only notifications from the OpenID of
		the sender are returned.</span></p>
		</li><li><p><b>desiredValues</b><span style="font-weight: normal;">: 
		Comma-separated list of values to return.  If missing, all values
		for each notification are returned.  If an unknown value is
		specified, it is ignored.</span></p>
		</li></ol>
	</li><li><p style="font-weight: normal;">Notifications are returned in the
	order that starts with the newest notification first.</p>
	</li><li><p style="font-weight: normal;">If all arguments are omitted,
	then all notifications are returned without changeData.</p>
	</li><li><p style="font-weight: normal;">The client is responsible for
	handling situations where an object has notifications outside of the
	range requested.</p>
	</li><li><p style="font-weight: normal;">Upon success, a 200 (OK) status
	code is returned.  The notifications returned are in JSON format.  A
	JSON array is used with the newest notification first.  The
	following values, except for changeData, are returned, unless
	desiredValues specifies a subset:</p>
</li></ol>
<ol><ol><li><p class="numbering-1-western"><b>notificationId</b></p>
		</li><li><p class="numbering-1-western"><b>timeStamp</b><span style="font-weight: normal;">:
		 The exact date/time when the notification was sent.  Represented
		as the number of milliseconds since January 1st 1970 UTC.</span></p>
		</li><li><p class="numbering-1-western"><b>state</b><span style="font-weight: normal;">:
		 Either read or unread</span></p>
		</li><li><p class="numbering-1-western"><b>sender</b><span style="font-weight: normal;">:
		 The notification's sender's OpenId.  This value can be omitted if
		the sender argument is sent.</span></p>
		</li><li><p class="numbering-1-western"><b>objectUrl</b><span style="font-weight: normal;">:
		 The URL to the document.  Displaying this URL in an iFrame should
		always work on simpler clients.</span></p>
		</li><li><p class="numbering-1-western"><b>title</b><span style="font-weight: normal;">:
		 The title of the document as of when the notification was sent.</span></p>
		</li><li><p class="numbering-1-western"><b>documentType</b><span style="font-weight: normal;">:
		 The document type.  Some particle clients might be able to provide
		enhanced capabilities for known document types.  For unknown
		document types, the url will be displayed in an iFrame.</span></p>
		</li><li><p class="numbering-1-western"><b>messageSummary</b><span style="font-weight: normal;">:
		 A summary of the notification that will be displayed in the GUI. 
		Examples include:</span></p>
	</li></ol></ol>
<ul><ul><ul><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			shared a document with you</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			updated the document</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			added you to the conversation</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			said: “...”</p>
		</li></ul></ul></ul>
<ol><ol><li><p class="numbering-1-western"><b>changeData</b><span style="font-weight: normal;">:
		 Only returned if explicitly requested in the desiredData argument.
		 This is because changeData can become burdensomely large.  If
		block is set to true, changeData is always included if new
		notifications arrive.</span></p>
	</li></ol><li><p class="numbering-1-western" style="font-weight: normal;">Upon
	failure, the server should send a 400-class error.</p>
</li></ol>
<h1 class="western" style="font-weight: normal;">Updating a
Notification's State</h1>
<p style="font-weight: normal;">The particle.updateNotificationState
is used to update a notification's state.</p>
<ol><li><p style="font-weight: normal;">The client sends a POST request
	to the particle.updateNotificationState endpoint with the following
	urlencoded arguments:</p>
	<ol><li><p><b>readNotificationIds</b><span style="font-weight: normal;">:
		 Comma-seperated list of notificationIds for notifications to be
		set to “read”</span></p>
		</li><li><p><b>unreadNotificationIds</b><span style="font-weight: normal;">:
		 Comma-seperated list of notificationIds for notifications to be
		set to “read”</span></p>
	</li></ol>
	</li><li><p style="font-weight: normal;">The server returns with 202
	(accepted) or a 4xx if an error occurs.</p>
	</li><li><p style="font-weight: normal;">All blocked requests for updates
	to notifications are completed.</p>
</li></ol>
<h1 class="western" style="font-weight: normal;">Updating an Object's
State</h1>
<p style="font-weight: normal;">The particle.updateObjectState is used
to update a object's state.  The following states are supported:</p>
<ul><li><p style="margin-bottom: 0in; font-weight: normal;">Ignore  (All
	new notifications to a given object / url are hidden)</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Unignore 
	(All new notifications to a given object / url are displayed.)</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">Delete (All
	notifications to a given object / url are ignored and currently
	saved ones are deleted.  The sender is asked to discontinue sending
	notifications.)</p>
	</li><li><p style="margin-bottom: 0in; font-weight: normal;">SilentDelete
	(Same as delete except that the sender isn't asked to discontinue
	sending notifications.)</p>
</li></ul>
<ol start="4"><li><p style="font-weight: normal;">The client sends a POST request
	to the particle.updateObjectState endpoint with the following
	urlencoded arguments:</p>
	<ol><li><p><b>objectId</b></p>
		</li><li><p><b>objectState</b><span style="font-weight: normal;">: 
		Either “ignore”, “unignore”, “delete”, or
		“silentDelete”.</span></p>
	</li></ol>
	</li><li><p style="font-weight: normal;">The server returns with 202
	(accepted) or a 4xx if an error occurs.  The 410 (Gone) state is
	used if the objectUrl is unknown.</p>
	</li><li><p style="font-weight: normal;">All blocked requests for updates
	to notifications are completed.</p>
</li></ol>
<p style="font-weight: normal;">Some servers might allow
silently-deleted objects to become unignored; although this is
implementation-dependent.</p>
<h1 class="western" style="font-weight: normal;">Blocking a user or
domain</h1>
<p>The particle.block endpoint is used to block a user or domain.</p>
<ol><li><p>A POST request is made to the particle.block endpoint with
	the following urlencoded argument:</p>
	<ol><li><p><b>toBlock</b>:  If this is a domain, then all senders from
		the given domain are blocked.  If this is a complete OpenID url,
		then the specific OpenID is blocked.</p>
	</li></ol>
	</li><li><p>A 202 (Accepted) is returned if successful, else a 4xx code
	is returned to indicate an error.</p>
</li></ol>
<h1 class="western" style="font-weight: normal;">Un-Blocking a user or
domain</h1>
<p>The particle.unBlock endpoint is used to un-block a user or
domain.</p>
<ol><li value="1"><p>A POST request is made to the particle.unBlock
	endpoint with the following urlencoded argument:</p>
	<ol><li><p><b>toUnBlock</b>:  If this is a domain, then all senders
		from the given domain are un-blocked.  If this is a complete OpenID
		url, then the specific OpenID is un-blocked.</p>
	</li></ol>
	</li><li><p>A 202 (Accepted) is returned if successful, else a 4xx code
	is returned to indicate an error.</p>
</li></ol>
<h1 class="western" style="font-weight: normal;">Getting all blocked
OpenIDs and domains</h1>
<p style="font-weight: normal;">The particle.getBlocked endpoint is
used to return data about blocked users and domains.  All blocked
domains and endpoints are returned as a single Javascript array with
a 200 (OK) error code.</p>
<h1 class="western" style="font-weight: normal;">Re-establish Trust</h1>
<p style="font-weight: normal;">TODO:  Perhaps
particle.reEstblishTrust endpoint with POST and urlencoded OpenID
argument?</p>
<h1 class="western" style="font-weight: normal;">Client Sending a
Notification</h1>
<p style="font-weight: normal;">When a client sends a notification, it
uses the particle.sendNotification endpoint to instruct its server to
send a notification.  This endpoint requires an active session
between the client and the server.</p>
<ol><li value="1"><p class="numbering-1-western" style="font-weight: normal;">
	The client sends a POST request to the particle.sendNotification
	endpoint.  The following urlencoded arguments are present:</p>
	<ol><li><p class="numbering-1-western"><b>openId</b><span style="font-weight: normal;">:
		 The openId of the notification's recipient.</span></p>
		</li><li><p class="numbering-1-western"><b>objectUrl</b><span style="font-weight: normal;">:
		 The URL to the document.  Displaying this URL in an iFrame should
		always work on simpler clients.  This value should never change,
		and is considered the object's unique ID.</span></p>
		</li><li><p class="numbering-1-western"><b>title</b><span style="font-weight: normal;">:
		 The title of the document.  This is always the newest version of
		the target object's title, and can change between notifications.</span></p>
		</li><li><p class="numbering-1-western"><b>documentType</b><span style="font-weight: normal;">:
		 The document type.  Some particle clients might be able to provide
		enhanced capabilities for known document types.  For unknown
		document types, the url will be displayed in an iFrame.</span></p>
		</li><li><p class="numbering-1-western"><b>messageSummary</b><span style="font-weight: normal;">:
		 A summary of the notification that will be displayed to the
		recipient. Examples include:</span></p>
	</li></ol>
</li></ol>
<ul><ul><ul><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			shared a document with you</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			updated the document</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			added you to the conversation</p>
			</li><li><p class="numbering-1-western" style="font-weight: normal;">Sender
			said: “...”</p>
		</li></ul></ul></ul>
<ol><ol><li><p class="numbering-1-western"><b>changeData</b><span style="font-weight: normal;">:
		 Additional data that describes the change.  This is only utilized
		if the client recognizes the documentType.  The specific format of
		changeData is defined by the documentType.  JSON is recommended,
		although any string-based encoding will work.</span></p>
	</li></ol><li><p class="numbering-1-western" style="font-weight: normal;">The
	following optional arguments are supported:</p>
</li></ol>
<ul><ul><li><p><b>forceRefreshSenderToken</b><span style="font-weight: normal;">:
		 Forces a refresh of the senderToken, defaults to false.</span></p>
		</li><li><p><b>forceRefreshEndpoints</b><span style="font-weight: normal;">:
		 Forces a refresh of the endpoints, defaults to false.</span></p>
		</li><li><p><b>maxRetries</b><span style="font-weight: normal;">:</span></p>
		</li><li><p><b>transportErrorDelay</b><span style="font-weight: normal;">:
		 The amount of time to wait until retrying if there is some kind of
		a transport error.</span></p>
	</li></ul></ul>
<ol start="3"><li><p class="numbering-1-western" style="font-weight: normal;">A 202
	(Accepted) is returned if the notification can be sent, elsewise an
	error is returned.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">A 403
	(Forbidden) returned indicates that the recipient asked to no longer
	receive notifications regarding this object.</p>
	</li><li><p class="numbering-1-western" style="font-weight: normal;">Implementations
	may choose to queue notifications and provide various retry
	capabilities in the event of a failure.</p>
</li></ol>
<p class="numbering-1-western" style="margin-left: 0in; font-weight: normal;">
Notes:</p>
<p class="numbering-1-western" style="margin-left: 0in; font-weight: normal;">
Notifications are not guaranteed to be sent.  It is recommended that
various clients and documentTypes utilize two-way notifications to
verify success and notify the user of errors.  It is also recommended
that clients use some kind of visual indicator to show what kind of
data hasn't had a confirmation notification.</p>
