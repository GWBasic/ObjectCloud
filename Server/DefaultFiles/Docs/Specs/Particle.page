{"Title":"Particle Specification","Contents":"<p>Particle is ObjectCloud's protocol for a distributed social network. &#160;It works by sending notifications to people and groups identified by an OpenID whenever an object identified by a URL is either shared or updated. &#160;Thus, every person and group can see what and when items are shared and updated. &#160;Particle works in a similar fashion to email, except that instead of transmitting an entire message, it merely tells the recipient that a message is available at a URL.</p><p>Particle is completely RESTful. &#160;Entire particle clients can be written in HTML and Javascript.</p><p>This document describes how Particle works. &#160;Its goal is to document enough of Particle so that independent implementations can be created, and non-web applications can act as Particle clients, much like how there are many email clients that use POP and IMAP.</p><p>Currently, Particle is designed for implementation simplicity and to meet ObjectCloud's needs. &#160;Future versions of Particle may merge or utilize open standards like Atom and PubHubSubBub. &#160;Independent&#160;implementors must be aware that, in Particle's early stages, no effort will be made for backwards compatibility.</p><p></p><p style=\"margin-bottom: 0in; \">The Particle System is designed to address the following technical needs:</p><p style=\"margin-bottom: 0in; \"></p><ul><li><b>Open and Distributed Social Networking</b>: &#160;The network of Particle-enabled web servers will create an open and distributed social network that can not be controlled by a single&#160;entity. &#160;ObjectCloud will serve as a reference&#160;implantation.</li><li><b>Email Version 2</b>: &#160;Particle can handle any data type that can be displayed in a web browser because it merely exchanges URLs. &#160;This allows Particle to act as a superior version of email.</li><li><b><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>OpenID and WebFinger integration</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \">: Particle is designed to work with OpenID accounts. A particle user is an OpenID user.</span></span></b></li><li><b><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>Ease of federation:</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \">&#160;Particle uses RESTful APIs, which are easier to work with and almost universally supported in all programming languages. &#160;ObjectCloud will serve as a working reference&#160;implementation&#160;that's usable out-of-the-box.</span></span></b></li><li><b>Thick Client Support</b>: &#160;The current design leaves room for thick clients, thus allowing \"super\" desktop clients and mobile applications.</li><li><b><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \"></span></span>Spam Control and&#160;</b><b>Security</b>: The \u201cspoofing\u201d problem common to email is designed out of the protocol.</li><li><b>Barrier to entry</b>: Servers can optionally choose to require that other servers have a signed SSL certificate for their domain. This creates a minor economic barrier to spam, and increases a message's origin's traceability.</li><li><b>Standard way for clients to block senders and domains</b>: &#160;A problem with email is that the proliferation of clients and standards means that people who use multiple clients often can't take advantage of anti-spam and blacklist capabilities.</li></ul><p></p><h1>History</h1><p>Particle was originally created in late summer 2009 as a proof-of-concept that ObjectCloud could provide an application similar to Google Wave, yet with a more approachable code base. &#160;Its original design goal was to allow concurrently editable documents using HTTP / REST instead of requiring a complicated stack of XMPP servers, like Google Wave did. &#160;Furthermore, its goal was to be documented enough that independent developers could use and replace pieces, unlike Google Wave which was very difficult to develop with. &#160;For example, Particle was based around OpenID as there is a lot of support on the web for OpenID authentication, but very little support for XMPP authentication.</p><p>As Particle was implemented in ObjectCloud, the notification part of the protocol was extended to all object types that the server supports. &#160;During development and demonstration of early versions of Particle, it became clear that this notification system, as opposed to concurrent document editing, was the more desirable feature. &#160;Likewise, concurrent document editing proved too unreliable to keep in the core of the protocol.&#160;&#160;In September 2010, it was decided to remove all concepts of concurrent&#160;document editing from Particle, and rely upon applications to provide such features outside of the protocol. &#160;Particle allows sharing anything with a URL, thus that URL can point to a concurrently-edited document.</p><h1>Overview of the\nnotification protocol</h1>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">In all cases, a\nsender or a client discover the particle endpoints in a manner\nsimilar to OpenID. The document returned from the OpenID uri will contain link tags that list all of the Particle endpoints.</p><p style=\"margin-bottom: 0in; font-weight: normal;\">The protocol has\ntwo stages between a sender and recipient:</p><p style=\"margin-bottom: 0in; font-weight: normal;\"></p><p style=\"margin-bottom: 0in; \"></p><ul><li>Establishing trust between the sender's server and the recipient's server</li><li>Sending notifications from a sender to a recipient</li></ul><p></p><p></p>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">The protocol also\nhas the following stages between a client and the server:</p><p style=\"margin-bottom: 0in; font-weight: normal;\"></p><p style=\"margin-bottom: 0in; \"></p><ul><li>Establishing a session between a client and a server</li><li>Load notifications between a date range</li><li>Live loading of incoming notifications using The Comet Protocol</li><li>Update the state of a notification to the following:</li><ul><li>read</li><li>unread</li></ul><li>Update an object's state to:</li><ul><li><b>Ignore</b>: &#160;All new notifications to a given object / url are hidden</li><li><b>Unignore</b>: &#160;All new notifications to a given object / url are displayed.</li><li><b>Delete</b>: &#160;All notifications to a given object / url are ignored and currently saved ones are deleted. The sender is asked to discontinue sending notifications.</li><li><b>SilentDelete</b>: &#160;Same as delete except that the sender isn't asked to discontinue sending notifications.</li></ul><li>Block sender or domain</li></ul><p></p><p></p>\n<h1>SSL</h1><p>SSL enables encrypted HTTP between clients and servers, and among servers as they send notifications to each other. &#160;This is required so that malicious parties can not impersonate each other.</p><p>In Particle, SSL is \"required\" at all times, although early versions of ObjectCloud's reference implementation will not use it. &#160;The reason why \"required\" is in quotes is that, in the future, the&#160;recommendation&#160;is that servers support a non-SSL mode for private experimentation in a controlled environment. &#160;SSL-Protected Particle implementations on the public internet must require SSL for all Particle activities.</p><p>Due to the complexity of setting up SSL, it is&#160;recommended&#160;that implementations of Particle try to streamline the processes as much as possible.</p><h1>Discovering the\nParticle Endpoint</h1>\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Discovering the\nparticle endpoint is performed in a manner similar to OpenID:</p>\n<ol><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Download the\n\tHTML document at the recipient's openID uri</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Scan the\n\t&lt;title&gt; section for &lt;link&gt; tags</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">All link tags\n\twhere the rel=\u201dparticle.\u201d are Particle endpoints.</p>\n</li></ol>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Particle endpoints\ncan be cached as a means of conserving resources.  It is recommended\nthat cached endpoints expire after a reasonable time, such as after a\n4 or 24-hour window.</p>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Example:</p>\n\n<p style=\"margin-bottom: 0in;\"><span style=\"font-weight: normal;\">for\nthe OpenID <a href=\"http://objectcloud.com/Users/GWBasic.user\">http://objectcloud.com/Users/GWBasic.user</a>:</span></p>\n\n<p style=\"margin-bottom: 0in;\"><span style=\"font-weight: normal;\">Downloading\n<a href=\"http://objectcloud.com/Users/GWBasic.user\">http://objectcloud.com/Users/GWBasic.user</a>\nyields:</span></p>\n\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">&lt;html&gt;&lt;head&gt;</pre>\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">\u2026</pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.establishTrust\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/UserDB?Method=establsihTrust</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.respondTrust\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=respondTrust</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.receiveNotification\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/UserDB?Method=receiveNotification</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.establishSession\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=establishSession</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.getNotifications\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=getNotifications</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.updateObjectState\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=updateObjectState</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.block\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=block</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.unBlock\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=unBlock</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">   \u2026</pre>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">All endpoints\nutilize urlencoded POST requests.  Argument names are case-sensitive.</p>\n<h1>Establishing Trust Between a Sender and Recipient</h1>\n<p style=\"font-weight: normal;\">In order to prevent the spoofing\nproblem that is common in email, trust must be established between a\nsender and a recipient.  The trust relationship establishes the\nfollowing facts:</p>\n<ul><li><p style=\"font-weight: normal;\">That the sender is who it says it\n\tis</p>\n\t</li><li><p style=\"font-weight: normal;\">That the sender has a\n\tregistered and signed domain</p>\n</li></ul>\n<p style=\"font-weight: normal;\">SSL will be required in future versions of Particle, thus ensuring that all participants have a registered domain, and thus have a&#160;verifiable&#160;identity.&#160;This creates a financial barrier to SPAMmers that is nominal for legitimate entities.&#160;&#160;Much like how email has blacklists, implementors may choose to implement blacklist mechanisms.</p><p style=\"font-weight: normal;\">Trust is established between a sender and recipients through the following steps:</p><ol><li>The sender sends a POST request to the recipient's particle.establishTrust endpoint. It has the following arguments:</li><ul><li><b>senderIdentity</b>: The sender's OpenID or WebFinger</li><li><b>avatar</b>: &#160;Base64-encoded image of the sender's avatar. &#160;This must be JPEG. &#160;Maximum size is 256K.</li><li><b>token</b>: A token to send back to the sender in order to establish trust. This is a string of any length up to 3K.</li><li><b>loginURL</b>: &#160;The URL to POST to when logging into this server with OpenID.</li><li><b>loginURLOpenID</b>: &#160;The POST argument for the user's OpenID.</li><li><b>loginURLWebFinger</b>: &#160;The POST argument for the user's webfinger if used instead of OpenID.</li><li><b>loginURLRedirect</b>: &#160;The POST argument for the URL that the user will be redirected to.</li></ul><li>While the sender's request is open, the recipient sends a POST request to the sender's particle.respondTrust endpoint. It has two arguments:</li><ul><li><b>token</b>: The token sent from the originating particle.establishTrust call</li><li><b>senderToken</b>: A string generated by the recipient that it uses to identify the sender. This can contain any character, and can be a maximum of 200 characters.</li></ul><li>The sender responds to the particle.respondTrust request with either a 202 (accepted) status code if the senderToken was established correctly, or a 4xx error code to indicate an error.</li><li>The recipient responds to the particle.establishTrust with either a 201 (Created) or a 4xx error code to indicate an error.</li></ol>\n<p style=\"font-weight: normal;\">Notes:</p>\n<p style=\"font-weight: normal;\">The recipient and sender will store\nthe senderToken in their own internal databases.  When sending\nnotifications, the senderToken is sent as a means of identifying who\nthe sender is.  The recipient can require that the sender obtain a\nnew senderToken at any time.</p>\n<p style=\"font-weight: normal;\">The requests described are\nsynchronous, that is, the sender does not return from the\nparticle.establishTrust request until after the particle.respondTrust\nis complete.</p>\n<p style=\"font-weight: normal;\">The token and senderToken can contain\nany string value.  It is recommended that clients utilize algorithms\nthat ensure that these strings are sufficiently random and hard to\nguess.</p>\n<p style=\"font-weight: normal;\">The sender should delete token during\nthe call to particle.respondTrust to prevent security violations.</p>\n<p style=\"font-weight: normal;\">SenderTokens are one-way. \nSpecifically, the token that Jack uses when sending notifications\nto Jill is different then what Jill uses to send notifications to\nJack.</p><p style=\"font-weight: normal;\">A web server may have a single endpoint for establishing trust. &#160;When a sender wishes to establish trust for multiple recipients that have the same particle.establishTrust endpoint, it must only establish trust once and use the same senderToken for all recipients.</p><p style=\"font-weight: normal;\">The loginURL arguments are to transparently log in&#160;when viewing a document on another server. &#160;Its purpose is so that a user can click on a link to a document on another server and not have to interact with the OpenID login process. &#160;It is&#160;recommended&#160;that, when the user clicks on a link that's to another server, the user is directed to a page that POSTs to loginURL in order to automate as much of the OpenID process as possible. &#160;This will give the illusion of seamless navigation.</p><p style=\"font-weight: normal;\">The sender should re-establish trust whenever the avatar image changes. &#160;Although not required, this is the only mechanism supported for updating clients of a new image.</p>\n<h1>Sending Notifications to a Server</h1><p>After trust is established, a server can send notifications to another server. &#160;When a server sends a notification to a recipient, the sending server uses the&#160;particle.receiveNotification\nendpoint.  In order to identify the OpenID that sent the notification&#160;the sender uses the\nsenderToken that it obtained when it established trust.  The sender\nmust be prepared to re-establish trust at any time.</p><p>When multiple recipients share a single&#160;particle.receiveNotification&#160;endpoint, a single call is made to the endpoint for all recipients, provided they have the same senderToken. &#160;If they have different senderTokens, then a&#160;separate&#160;call is made for each unique senderToken.</p><p></p><p></p><ol><li>The sender sends a POST request to the particle.receiveNotification endpoint. The following urlencoded arguments are present:</li><ul><li><b>senderToken</b>: This is the senderToken established during the calls to particle.establishTrust and particle.respondTrust. It identifies the sender and prohibits spoofing</li><li><b>recipients</b>: &#160;JSON array of recipients; either OpenIDs or WebFingers.</li><li><b>objectUrl</b>: The URL to the document. This value should never change, and is considered the object's unique ID. &#160;It is limited to 500 characters.</li><li><b>summaryView</b>: &#160;The document's summary view. &#160;This must be no more then 1.5K.&#160;&#160;(See \"Summary Views\" section.)</li><li><b>documentType</b>: The document type. This can be any value under 20 characters. &#160;Like file extensions in a desktop operating system, well-known document types can be established by convention.</li><li><b>verb</b>: &#160;Valid values are create, update, delete, share, link.</li><li><b>changeData</b>: &#160;undefined for create, update, and delete. &#160;For share, JSON array of all of the current recipients. &#160;For link, a JSON object with the following properties:</li></ul><ol><ul><li><b>linkUrl</b>: &#160;The URL that's linked to</li><li><b>linkSummaryView</b>: &#160;The summary view of the linked object.</li><li><b>linkDocumentType</b>: &#160;The linked object's document type. &#160;This uses the same convention as document type for all objects.</li><li><b>ownerIdentity</b>: &#160;The webFinger or OpenID of the owner of the linked object.</li><li><b>linkID</b>: &#160;An ID that is used to identify the notification so that the owner can send a matching notification.</li></ul></ol><li>If the senderToken is unknown or trust needs to be re-established, then recipient responds with a 412 (precondition failed.) and the text \u201csenderToken\u201d. The sender should use the provider.establishTrust endpoint to get a new senderToken, and then re-send the notification.</li><li>If the notification was sent successfully, then the recipient responds with a 200 (OK).</li><li>In the event of any error, the recipient responds with a 202 (accepted) and a JSON object with detailed error information.</li><ul><li><b>summaryView</b>: &#160;If this property is present it indicates an error with the summary view. &#160;The value must be a human-readable, English description of the error or errors.</li><li><b>changeData</b>: &#160;If this property is present, it indicates an error with the changeData. &#160;The value must be a human-readable, English description of the error or errors.</li><li><b>recipient OpenIDs or WebFingers</b>: &#160;For each recipient that there is a problem with, the JSON object must have a property with the recipient's OpenID or WebFinger. &#160;Valid values are:</li><ul><li><b>blocked</b>: &#160;Sender should not send to this recipient any more. &#160;(Unimplemented)</li><li><b>notFound</b>: &#160;Recipient does not exist.</li><li><b>blockedObject</b>: &#160;Recipient does not wish to get notifications for this object any more. &#160;(Unimplemented)</li><li><b>error</b>: &#160;An internal error prevented sending the recipient this notification.</li></ul></ul><li>After&#160;receiving&#160;a notification, the recipient should update any open clients through Comet. &#160;(See \"Waiting for New Notifications with Comet\")</li></ol><p></p><p>Notes:</p>\n<p style=\"font-weight: normal;\">Object creation is implicit; that is,\na recipient becomes aware of an object as soon as it gets a\nnotification that has the object's objectUrl as an argument. \nRecipients should store the objectUrl of objects that are deleted,\nthis way they do not become aware of objects again if they continue\nto receive unwanted notifications.</p><p style=\"font-weight: normal;\">The \"link\" verb is intended for items like replies and attachments. &#160;All recipients should have permission to access the item that was linked, although they may not&#160;receive&#160;notifications with regard to the linked item. &#160;For security reasons, the ownerIdentity must send an&#160;independent&#160;verification with the same linkID. &#160;This is described in the next section.</p><h1>Verifying Links</h1><p style=\"font-weight: normal;\">The link verb introduces a potential security and spoofing situation. &#160;Although notification's senders are verified, if links aren't verified, a&#160;malicious&#160;party could claim that any user added a link. &#160;This could be implemented as false&#160;endorsements. &#160;To prevent libel, the Particle protocol uses a 3-way link verification system.</p><p style=\"font-weight: normal;\">In this system, there are three parties:</p><p style=\"font-weight: normal;\"><ol><li><b>Host server</b>: &#160;This server has the objects being linked.</li><li><b>Recipient server</b>: &#160;This server&#160;receives&#160;notifications about objects being linked.</li><li><b>Identity server</b>: &#160;This server provides the OpenID.</li></ol></p><p>In general, when a user adds a link, for example, by replying to another user's status, the following happens: &#160;The host server starts sending notifications to recipient servers and directs the user to a page on the identity server where the user confirms that he or she made the link. &#160;The identity server then also sends confirmations of the notifications to recipient servers. &#160;The recipient servers verify that the notification matches the confirmations and then processes the notifications.</p><p>The following endpoints are used for confirmation:</p><p><ul><li><b>particle.confirmLinkPage</b>: &#160;The user's browser is directed by the host server to POST to this page.</li><li><b>particle.confirmLink</b>: &#160;The identity server POSTs to this endpoint on recipients to verify that the notification is valid.</li></ul></p><p>A more detailed&#160;explanation&#160;of the process is as follows:</p><p><ol><li>User creates a link, such as by replying to a status.</li><li>Host server sends notifications as described above.</li><li>Host server directs the user's browser to POST to the user's particle.confirmLinkPage endpoint on the identity server. &#160;This post has the following URLencoded arguments:</li><ul><li></li><li><b>objectUrl</b>: &#160;Same as original notification.</li><li><b>ownerIdentity</b>:<meta charset=\"utf-8\"/>&#160;&#160;Same as original notification.</li><li><b>linkedSummaryView</b>:<meta charset=\"utf-8\"/>&#160;&#160;Same as original notification.</li><li><b>linkUrl</b>:<meta charset=\"utf-8\"/>&#160;&#160;Same as original notification.</li><li><b>linkDocumentType</b>:<meta charset=\"utf-8\"/>&#160;&#160;Same as original notification.</li><li><b>recipients</b>: &#160;JSON array of all of the recipients of the notification.</li><li><b>redirectUrl</b>: &#160;URL to redirect the user to after the user confirms that the link is valid.</li><li><b>linkID</b>:<meta charset=\"utf-8\"/>&#160;&#160;Same as original notification.</li></ul><li>It is&#160;recommended&#160;that implementations give the user a way to specify that they trust the domain from ObjectURL, this way they don't have to confirm every time.</li><li>The identity server establishes trust with all recipients if it has not done so.</li><li>When the user confirms, each recipient's particle.confirmLink is called. &#160;Like&#160;<meta charset=\"utf-8\"/>particle.receiveNotification, a single call is made for each unique particle.confirmLink. &#160;Thus, if multiple recipients share the same&#160;<meta charset=\"utf-8\"/>particle.confirmLink, only a single call is made. &#160;The following URLencoded arguments are present:</li><ul><li><meta charset=\"utf-8\"/></li><li><b>objectUrl</b>: &#160;Same as original notification.</li><li><b>senderToken</b>:&#160;&#160;The linked object's owner's senderToken for the server.</li><li><b>linkedSummaryView</b>:&#160;&#160;Same as original notification.</li><li><b>linkUrl</b>:&#160;&#160;Same as original notification.</li><li><b>linkDocumentType</b>:&#160;&#160;Same as original notification.</li><li><b>recipients</b>: &#160;JSON array of all of the recipients of the notification on the specific server.</li><li><b>linkID</b>:&#160;&#160;Same as original notification.</li></ul><li>The recipient server verifies that objectUrl, linkedSummaryView, linkUrl, linkDocumentType, and linkID match. &#160;Only the&#160;intersection&#160;of both sets of recipients, those from the notification and those from the confirmation, actually get the notification.</li></ol></p><p style=\"font-weight: normal;\">Currently, sending confirmations and notifications are \"send and forget.\" &#160;There is no way to be aware of or handle errors or situations where&#160;notifications&#160;receive&#160;no confirmation.</p><p style=\"font-weight: normal;\">Receivers&#160;must be prepared to&#160;receive&#160;notifications and confirmations in any order. &#160;This is because network conditions and load may cause a confirmation to come before a notification.</p><p style=\"font-weight: normal;\">Receivers&#160;must be prepared to&#160;receive&#160;confirmations late. &#160;A user may take a long time to confirm. &#160;A useful window is to hold notifications for at least an hour before discarding.</p><h1>Summary Views</h1><p style=\"font-weight: normal;\">The summary view is a short snippit of xhtml. &#160;(Valid HTML 5 xml).&#160;&#160;In the UI, summary views of objects will be displayed, thus summary views must be somewhat compact.</p><p style=\"font-weight: normal;\">The sent xhtml must not use namespaces. &#160;It does not need to be a complete document, and can contain multiple top-level tags. &#160;Implementations need to be aware that summary views are incomplete documents.</p><p style=\"font-weight: normal;\">The xhtml varient of HTML 5, as opposed to the SGML varient, is used because of the huge amount of xml processing&#160;libraries&#160;available, as opposed to HTML processing libraries. &#160;This allows clients to quickly process and filter summary views so that insure tags can be filtered out. &#160;It is also trivial to convert parsed xhtml to SGML HTML, although the converse isn't always the case because SGML HTML parsers are less common then xml parsers. &#160;(TODO: &#160;Research to find out if it is more appropriate to use \"polygot\" HTML, which is both valid xml and sgml at the same time.)</p><p style=\"font-weight: normal;\">For security reasons, only a limited amount of tags and attributes are supported. &#160;An even more limited amount of styles are supported. &#160;This prevents cross-site-scripting and SPAM through abusive use of tags. &#160;Servers MUST filter summary views prior to sending them to the client.</p><p style=\"font-weight: normal;\">Supported tags and attributes:</p><p style=\"font-weight: normal;\"></p><ul><li><b>p</b>:</li><li><span class=\"s1\"></span><b>div</b>:</li><li><span class=\"s1\"></span><b>span</b>:<span class=\"s1\">&#160;</span></li><li><span class=\"s1\"></span><b>a</b>: href, alt, target &#160;(Note, valid values for target are _blank and _top.&#160;&#160;Without the target attribute, the link may be displayed in an iFrame.)</li><li><span class=\"s1\"></span><b>br</b>:</li><li><b>img</b>:<span class=\"s1\">&#160;src, alt</span></li><li><span class=\"s1\"></span><b>b</b>:</li><li><span class=\"s1\"></span><b>em</b>:</li><li><span class=\"s1\"></span><b>i</b>:</li><li><span class=\"s1\"></span><b>li</b>:</li><li><span class=\"s1\"></span><b>ol</b>:<span class=\"s1\">&#160;</span></li><li><span class=\"s1\"></span><b>ul</b>:</li></ul><p></p><p style=\"font-weight: normal;\">Supported classes:</p><p style=\"font-weight: normal;\"></p><ul><li><b>particle_large</b>: Items with this class should be larger then normal</li><li><b>particle_small</b>: Items with this class should be smaller then normal</li><li><b>particle_emphasis</b>: Items with this class should somehow be&#160;emphasized&#160;in the display</li><li><b>particle_right</b>: &#160;Items with this class should float to the right</li><li><b>particle_left</b>: &#160;Items with this class should float to the left</li><li><b>particle_clear</b>: &#160;Items with this class should clear a float</li></ul><p></p>(Tags, attributes, and classes that aren't explicitly supported in this spec should be filtered out for security reasons.)<p style=\"font-weight: normal;\">Servers should consider filtering the &lt;img&gt; tag to direct the target through a proxy. &#160;This proxy should ensure that images aren't too large on screen, and should ensure that images aren't too large of a download.</p><p style=\"font-weight: normal;\">Servers should consider filtering the &lt;a&gt; tag so that the user is automatically logged in through OpenID using the loginURL* values sent when establishing trust.</p><p style=\"font-weight: normal;\"></p><h1>Establishing a session for thick clients and dedicated devices</h1><p></p><p style=\"font-weight: normal; \">The particle.establishSession endpoint is used to allow a client program to establish a session to display notifications. This is primarily intended for use with mobile devices and thick clients. Web-based clients where the Particle endpoints reside on the same server as the HTML can use whatever system they desire for authentication.</p><p style=\"font-weight: normal; \">Future modifications to the protocol might replace this with a more secure means of establishing a session.</p><p style=\"font-weight: normal; \"></p><p></p><ol><li>The client program or device stores the OpenID / WebFinger and password.</li><li>The client program uses the OpenID / WebFinger to discover the particle.establishSession endpoint.</li><li>The client program makes a POST request to particle.establishSession with the following urlencoded argument:</li><ol><li><b>username</b>: &#160;Either the OpenID, webfinger, email address, username, ect.</li><li><b>password</b>: The password</li></ol><li>The http status code 202 (accepted) is returned to indicate that the session was created successfully. Any 4xx response indicates some form of error.</li></ol><p></p><p style=\"font-weight: normal; \">It is assumed that session will be maintained through HTTP cookies or HTTP sessions. Therefore, the client program or device should use an HTTP library that can persist session-level cookies or that supports HTTP sessions. &#160;More&#160;discussion&#160;on this is TODO.</p><p style=\"font-weight: normal;\"></p><h1>Getting Notifications</h1><p></p><p style=\"font-weight: normal; \">The particle.getNotifications endpoint allows any client or device to get all notifications or a subset of recent notifications. Prior to using this endpoint, a session must be established using particle.establishSession or through the web server's UI.</p><p style=\"font-weight: normal; \">All notifications have a notification ID. This is an unsigned integer. The first notification has a low ID, and each subsequent notification received has one value higher. Notification IDs are immutable. &#160;Skipping notificationIDs is supported, but it is&#160;recommended&#160;that it's only performed when culling redundant data. If a notification is deleted from the database, its ID should never be re-used. The lowest ID is implementation-specific; clients should not expect the lowest notificationId to be 0, 1 or some other constant.</p><p style=\"font-weight: normal; \">There is no highest value of notification ID. Implementations should be designed such that this ID can become very large. 64-bit unsigned integers are recommended as a minimum size.</p><p style=\"font-weight: normal; \"></p><p></p><ol><li>The client sends a GET request to the particle.getNotifications endpoint with the following optional urlencoded arguments:</li><ol><li><b>newestNotificationId</b>: The highest notificationId allowed.</li><li><b>oldestNotificationId</b>: The lowest notificationId allowed.</li><li><b>maxNotifications</b>: The maximum number of notifications that are to be returned. Older notifications are filtered out if needed.</li><li><b>objectUrls</b>: JSON array. &#160;If present, only notifications for the given URLs are returned.</li><li><b>senderIdentities</b>: JSON array. &#160;The senders' OpenIds. If present, only notifications from the given OpenIDs are returned.</li><li><b>desiredValues</b>: JSON array. &#160;Names of values to return. &#160;(See below.) &#160;If missing, all values for each notification are returned. If an unknown value is specified, it is ignored.</li><li><b>includeIgnored</b>: &#160;When \"true\", notifications for ignored objects are returned. &#160;Any other value, or missing, indicates that ignored objects should be omitted.</li></ol><li>Notifications are always returned in descending chronological order. &#160;(Newest notification first.)</li><li>The client is responsible for handling situations where an object has notifications outside of the range requested.</li><li>Upon success, a 200 (OK) status code is returned. The notifications returned are in JSON format. A JSON array is used with the newest notification first. The following values are returned, unless desiredValues specifies a subset:</li><ol><li><b>notificationId</b></li><li><b>timeStamp</b>: The exact date/time when the notification was recieved. Represented as the number of milliseconds since January 1st 1970 UTC.</li><li><b>senderIdentity</b>: The notification's sender's OpenId or webfinger.</li><li><b>senderAvatarUrl</b>: &#160;URL to the sender's avatar.</li><li><b>objectUrl</b>: The URL to the document.</li><li><b>documentType</b>: The document type. Some particle clients might be able to provide enhanced capabilities for known document types. For unknown document types, the url will be displayed in an iFrame.</li><li><b>summaryView</b>: &#160;The object's summary view. &#160;This must be filtered for secure display.</li><li><b>verb</b>: &#160;The notification's verb</li><li><b>changeData</b>: &#160;The notification's changeData</li><li><b>ignored</b>: &#160;Either true or false, indicates if the object with the given URL is ignored.</li><li><b>linkedSenderIdentity</b>: &#160;The linked sender identity.</li></ol><li>Upon failure, the server should send a 400-class error.</li></ol><p>Servers may delete old notifications in order to save space, although they should attempt to keep all unique data. &#160;For example, a server may delete many old&#160;create, update, delete, share notifications, but keep link notifications.</p><div><p>When the verb is \"link,\" changeData will also include the ownerAvatar&#160;property.</p><p></p><h2>Displaying the Sender's Avatar</h2><p style=\"font-weight: normal;\">The URL for all avatars must support the following GET arguments:</p><p style=\"font-weight: normal;\"></p><ul><li><b>width</b>: &#160;The absolute width of the avatar. &#160;When only width is specified, scaling will be proportional and will preserve the aspect ratio.</li><li><b>height</b>:&#160;The absolute height of the avatar. &#160;When only width is specified, scaling will be proportional and will preserve the aspect ratio.</li><li><b>maxWidth</b>: &#160;The maximum width of the avatar. &#160;If the avatar is wider then this width, it will be shrunk proportionally.</li><li><b>maxHeight</b>: &#160;The maximum height of the avatar. &#160;If the avatar is taller then this height, it will be shrunk proportionally.</li></ul><p></p><p style=\"font-weight: normal;\">Remember, avatars are stored on the recipient's server. &#160;Thus, the recipient must support all resizing logic.</p><h2>Waiting for New Notifications with Comet</h2><p>The particle system allows a client to know exactly when a notification arrives.&#160; This is accomplished with a layer 3 Queuing and Reliable Comet session.&#160; (The Comet Protocol is document at <a target=\"_blank\" title=\"\" href=\"/Docs/Specs/Comet%20Protocol.page\">/Docs/Specs/Comet Protocol.page)</a></p><p><a target=\"_blank\" title=\"\" href=\"/Docs/Specs/Comet%20Protocol.page\"></a>To wait for incoming notifications, establish a Queuing and Reliable Comet session at the particle.incomingNotificationEvent endpoint.&#160; The server will send each notification as it arrives.&#160; Notifications are sent as JSON objects using the same format as recieveNotification endpoint, except that all columns are always present.</p><p>In some cases, a state may change on the server where the UI is out of sync, such as if a user chooses to ignore or delete notifications. &#160;In this case, instead of a JSON array, a string \"refresh\" will be sent. &#160;How clients interpret this string is implementation-dependent, but it is&#160;recommended&#160;that they pop up a dialog box encouraging the user to refresh.</p><p>Future versions of the protocol may send a more detailed set of changes as object states change. &#160;When older clients get unrecognized commands, they should behave as if \"refresh\" was sent.</p><div>\n<h1>Updating an Object's\nState</h1>\n<p style=\"font-weight: normal;\">The particle.updateObjectState is used\nto update a object's state.  The following states are supported:</p><p style=\"font-weight: normal;\"></p><p></p><ul><li><b>Ignore</b>: All new notifications to a given object / url are hidden.</li><li><b>Unignore</b>: All new notifications to a given object / url are displayed.</li><li><b>Delete</b>: All notifications to a given object / url are ignored and currently saved ones are deleted. The sender is asked to discontinue sending notifications.</li><li><b>SilentDelete</b>: Same as delete except that the sender isn't asked to discontinue sending notifications. &#160;The server will continue to process&#160;notifications as if the user intended to read them.</li></ul>(Note: &#160;are all these states needed? &#160;Perhaps this is overcomplicating things?)<p></p><p></p><p></p><ol><li>The client sends a POST request to the particle.updateObjectState endpoint with the following urlencoded arguments:</li><ul><li><b>objectUrl</b></li><li><b>objectState</b>: Either \u201cignore\u201d, \u201cunignore\u201d, \u201cdelete\u201d, or \u201csilentDelete\u201d.</li></ul><li>The server returns with 202 (accepted) or a 4xx if an error occurs. The 410 (Gone) state is used if the objectUrl is unknown.</li><li>The \"refresh\" string is sent to any clients that are waiting for new notifications through Comet.</li></ol><p></p>\n<h1>Blocking (TODO)</h1><p>Blocking users and domains is currently TODO. &#160;When getting back to this part of the spec, consider using an explicit whitelist and an explicit blacklist.</p><p>Also consider letting users blacklist everything as a means of only letting whitelisted users and organizations get through.</p><h2>Blocking a user or\ndomain</h2>\n<p>The particle.block endpoint is used to block a user or domain.</p><p></p><p></p><ol><li>A POST request is made to the particle.block endpoint with the following urlencoded argument:</li><ul><li><b>toBlock</b>: If this is a domain, then all senders from the given domain are blocked. If this is a complete OpenID url, then the specific OpenID is blocked. &#160;If this is a WebFinger, then all messages from the WebFinger are blocked.</li></ul><li>A 202 (Accepted) is returned if successful, else a 4xx code is returned to indicate an error.</li></ol>Blocking an entire domain should block all subdomains.<p></p>\n<h2>Un-Blocking a user or\ndomain</h2>\n<p>The particle.unBlock endpoint is used to un-block a user or\ndomain.</p><p></p><p></p><ol><li>A POST request is made to the particle.unBlock endpoint with the following urlencoded argument:</li><ul><li><b>toUnBlock</b>: If this is a domain, then all senders from the given domain are un-blocked. If this is a complete OpenID url, then the specific OpenID is un-blocked.</li></ul><li>A 202 (Accepted) is returned if successful, else a 4xx code is returned to indicate an error.</li></ol>Note: &#160;Un-blocking a single OpenID or WebFinger will not work if the entire domain is blocked. &#160;Un-blocking a subdomain will not work if parent domains are blocked.<p></p>\n<h2>Getting all blocked\nOpenIDs and domains</h2>\n<p style=\"font-weight: normal;\">The particle.getBlocked endpoint is\nused to return data about blocked users and domains.  All blocked\ndomains and endpoints are returned as a single JSON array with\na 200 (OK) error code.</p><h1>TODOs</h1><p>Friendship: &#160;There needs to be a way to establish mutual friendship. &#160;Twitter-style following is accomplished through groups and UI. &#160;Friendship, on the other hand, requires a light handshake which is TBD. &#160;Potential way to allow friendship is with an endpoint, particle.willYouBeMyFriend, that takes a senderToken as an argument.</p><p>Groups: &#160;ObjectCloud, the reference&#160;implementation, supports groups as a convenient way to organize permissions. &#160;There needs to be a way for groups to have a place, page, and ability to share without overloading users with too many notifications. &#160;Not sure how to address this.</p><h1>Weaknesses</h1><p>Currently, this protocol does not address what happens when a user logs into a server with an OpenID and shares items with other people. &#160;It assumes that the user who initiated the action comes from the server where the data is stored. &#160;A provision is made for \"linking\" so that users from many different servers can discuss an item.</p>\n</div></div>"}