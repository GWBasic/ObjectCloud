{"Title":"Particle Specification","Contents":"<p>Particle is ObjectCloud's protocol for a distributed social network. &#160;It works by sending notifications to people and groups identified by an OpenID whenever an object identified by a URL is either shared or updated. &#160;Thus, every person and group can see what items are shared and updated. &#160;Particle works in a similar fashion to email, except that instead of transmitting an entire message, it merely tells the recipient that a message is available at a URL.</p><p>This document describes how Particle works. &#160;Its goal is to document enough of Particle so that independent implementations can be created, and non-web applications can act as Particle clients, much like how there are many email clients that use POP and IMAP.</p><p>Currently, Particle is designed for implementation simplicity and to meet ObjectCloud's needs. &#160;Future versions of Particle may merge or utilize open standards like Atom and PubHubSubBub. &#160;Independent&#160;implementors must be aware that, in Particle's early stages, no effort will be made for backwards compatibility.</p><p><meta charset=\"utf-8\"/></p><p style=\"margin-bottom: 0in; \">The Particle System is designed to address the following technical needs:</p><p style=\"margin-bottom: 0in; \"><ul><li><b>Open and Distributed Social Networking</b>: &#160;The network of Particle-enabled web servers will create an open and distributed social network that can not be controlled by a single&#160;entity. &#160;ObjectCloud will serve as a reference&#160;implantation.</li><li><b>Email Version 2</b>: &#160;Particle can handle any data type that can be displayed in a web browser because it merely exchanges URLs. &#160;This allows Particle to act as a superior version of email.</li><li><b><meta charset=\"utf-8\"/><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>OpenID and WebFinger integration</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \">: Particle is designed to work with OpenID accounts. A particle user is an OpenID user.</span></span></b></li><li><b><meta charset=\"utf-8\"/><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><b>Ease of federation:</b></span><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \">&#160;Particle uses RESTful APIs, which are easier to work with and almost universally supported in all programming languages. &#160;ObjectCloud will serve as a working reference&#160;implementation&#160;that's usable out-of-the-box.</span></span></b></li><li><b><span class=\"Apple-style-span\" style=\"font-weight: normal; \"><span style=\"font-weight: normal; \"></span></span>Spam Control and&#160;</b><meta charset=\"utf-8\"/><b>Security</b>: The \u201cspoofing\u201d problem common to email is designed out of the protocol.</li><li><meta charset=\"utf-8\"/><b>Barrier to entry</b>: Servers can optionally choose to require that other servers have a signed SSL certificate for their domain. This creates a minor economic barrier to spam, and increases a message's origin's traceability.</li><li><meta charset=\"utf-8\"/><b>Standard way for clients to block senders and domains</b>: &#160;A problem with email is that the proliferation of clients and standards means that people who use multiple clients often can't take advantage of anti-spam and blacklist capabilities.</li></ul></p><h1>History</h1><p>Particle was originally created in late summer 2009 as a proof-of-concept that ObjectCloud could provide an application similar to Google Wave, yet with a more approachable code base. &#160;Its original design goal was to allow concurrently editable documents using HTTP / REST instead of requiring a complicated stack of XMPP servers, like Google Wave did. &#160;Furthermore, its goal was to be documented enough that independent developers could use and replace pieces, unlike Google Wave which was very difficult to develop with. &#160;For example, Particle was based around OpenID as there is a lot of support on the web for OpenID authentication, but very little support for XMPP authentication.</p><p>As Particle was implemented in ObjectCloud, the notification part of the protocol was extended to all object types that the server supports. &#160;During development and demonstration of early versions of Particle, it became clear that this notification system, as opposed to concurrent document editing, was the more desirable feature. &#160;Likewise, concurrent document editing proved too unreliable to keep in the core of the protocol.&#160;&#160;In September 2010, it was decided to remove all concepts of concurrent&#160;document editing from Particle, and rely upon applications to provide such features outside of the protocol. &#160;Particle allows sharing anything with a URL, thus that URL can point to a concurrently-edited document.</p><h1>Overview of the\nnotification protocol</h1>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">In all cases, a\nsender or a client discover the particle endpoints in a manner\nsimilar to OpenID. The document returned from the OpenID uri will contain link tags that list all of the Particle endpoints.</p><p style=\"margin-bottom: 0in; font-weight: normal;\">The protocol has\ntwo stages between a sender and recipient:</p>\n<ul><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Establishing\n\ttrust between a sender and a recipient</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Sending\n\tnotifications from a sender to a recipient</p>\n</li></ul>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">The protocol also\nhas the following stages between a client and the server:</p>\n<ul><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Establishing\n\ta session between a client and a server using The Comet Protocol</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Receiving new\n\tnotifications since a particular date</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Update the\n\tstate of a notification to the following:</p>\n\t<ul><li><p style=\"margin-bottom: 0in; font-weight: normal;\">read</p>\n\t\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">unread</p>\n\t</li></ul>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Update an\n\tobject's state to:</p>\n\t<ul><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Ignore  (All\n\t\tnew notifications to a given object / url are hidden)</p>\n\t\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Unignore \n\t\t(All new notifications to a given object / url are displayed.)</p>\n\t\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Delete (All\n\t\tnotifications to a given object / url are ignored and currently\n\t\tsaved ones are deleted.  The sender is asked to discontinue sending\n\t\tnotifications.)</p>\n\t\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">SilentDelete\n\t\t(Same as delete except that the sender isn't asked to discontinue\n\t\tsending notifications.)</p>\n\t</li></ul>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Block sender\n\tor domain</p>\n</li></ul>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Some\nimplementations may optionally allow a change from SilentDelete to\nUnignore.</p>\n<h1>SSL</h1><p>SSL enables encrypted HTTP between clients and servers, and among servers as they send notifications to each other. &#160;This is required so that malicious parties can not impersonate each other.</p><p>SSL WILL NOT be used in early development versions of Particle. &#160;This is because setting up security certificates can be complicated. &#160;Future versions of Particle will require SSL at all times in order to work properly.</p><p>Due to the complexity of setting up SSL, it is&#160;recommended&#160;that implementations of Particle try to streamline the processes as much as possible.</p><h1>Discovering the\nParticle Endpoint</h1>\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Discovering the\nparticle endpoint is performed in a manner similar to OpenID:</p>\n<ol><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Download the\n\tHTML document at the recipient's openID uri</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Scan the\n\t&lt;title&gt; section for &lt;link&gt; tags</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">All link tags\n\twhere the rel=\u201dparticle.\u201d are Particle endpoints.</p>\n</li></ol>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Particle endpoints\ncan be cached as a means of conserving resources.  It is recommended\nthat cached endpoints expire after a reasonable time, such as after a\n4 or 24-hour window.</p>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">Example:</p>\n\n<p style=\"margin-bottom: 0in;\"><span style=\"font-weight: normal;\">for\nthe OpenID <a href=\"http://objectcloud.com/Users/GWBasic.user\">http://objectcloud.com/Users/GWBasic.user</a>:</span></p>\n\n<p style=\"margin-bottom: 0in;\"><span style=\"font-weight: normal;\">Downloading\n<a href=\"http://objectcloud.com/Users/GWBasic.user\">http://objectcloud.com/Users/GWBasic.user</a>\nyields:</span></p>\n\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">&lt;html&gt;&lt;head&gt;</pre>\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">\u2026</pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.establishTrust\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.respondTrust\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=respondTrust</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.receiveNotification\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=receiveNotification</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.establishSession\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=establishSession</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.getNotifications\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=getNotifications</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.updateNotificationState\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=updateNotificationState</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.updateObjectState\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=updateObjectState</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.block\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=block</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.unBlock\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=unBlock</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; margin-left: 40px;\">   <span style=\"font-weight: normal;\">&lt;link\nrel=\u201dparticle.sendNotification\u201d\nhref=\u201d<a href=\"http://objectcloud/Users/GWBasic/part.icle?Method=establsihTrust\">https://objectcloud/Users/GWBasic/part.icle?Method=sendNotification</a>\u201d\n/&gt;</span></pre>\n<pre style=\"margin-bottom: 0in; font-weight: normal; margin-left: 40px;\">   \u2026</pre>\n\n<p style=\"margin-bottom: 0in; font-weight: normal;\">All endpoints\nutilize urlencoded POST requests.  Argument names are case-sensitive.</p>\n<h1>Establishing Trust</h1>\n<p style=\"font-weight: normal;\">In order to prevent the spoofing\nproblem that is common in email, trust must be established between a\nsender and a recipient.  The trust relationship establishes the\nfollowing facts:</p>\n<ul><li><p style=\"font-weight: normal;\">That the sender is who it says it\n\tis</p>\n\t</li><li><p style=\"font-weight: normal;\">That the sender has a\n\tregistered and signed domain</p>\n</li></ul>\n<p style=\"font-weight: normal;\">SSL will be required in future versions of Particle, thus ensuring that all participants have a registered domain, and thus have a&#160;verifiable&#160;identity.&#160;This creates a financial barrier to SPAMmers that is nominal for legitimate entities.&#160;&#160;Much like how email has blacklists, implementors may choose to share blacklists of SPAM domains.</p><p style=\"font-weight: normal;\">Trust is established between a sender and recipient through the following steps:</p><ol><li>The sender sends a POST request to the recipient's particle.establishTrust endpoint. It has two arguments:</li><ol><li><b>sender</b>: The sender's OpenID</li><li><b>token</b>: A token to send back to the sender in order to establish trust. This is a string of any length up to 3K.</li><li><b>loginURL</b>: &#160;The URL to POST to when logging into this server with OpenID.</li><li><b>loginURLOpenID</b>: &#160;The POST argument for the user's OpenID.</li><li><b>loginURLWebFinger</b>: &#160;The POST argument for the user's webfinger if used instead of OpenID.</li><li><b>loginURLRedirect</b>: &#160;The POST argument for the URL that the user will be redirected to.</li></ol><li>While the sender's request is open, the recipient sends a POST request to the sender's particle.respondTrust endpoint. It has two arguments:</li><ol><li><b>token</b>: The token sent from the originating particle.establishTrust call</li><li><b>senderToken</b>: A string generated by the recipient that it uses to identify the sender. This can contain any character, and can be a maximum of 200 characters.</li></ol><li>The sender responds to the particle.respondTrust request with either a 202 (accepted) status code if the senderToken was established correctly, or a 4xx error code to indicate an error.</li><li>The recipient responds to the particle.establishTrust with either a 201 (Created) or a 4xx error code to indicate an error.</li></ol>\n<p style=\"font-weight: normal;\">Notes:</p>\n<p style=\"font-weight: normal;\">The recipient and sender will store\nthe senderToken in their own internal databases.  When sending\nnotifications, the senderToken is sent as a means of identifying who\nthe sender is.  The recipient can require that the sender obtain a\nnew senderToken at any time.</p>\n<p style=\"font-weight: normal;\">The requests described are\nsynchronous, that is, the sender does not return from the\nparticle.establishTrust request until after the particle.respondTrust\nis complete.</p>\n<p style=\"font-weight: normal;\">The token and senderToken can contain\nany string value.  It is recommended that clients utilize algorithms\nthat ensure that these strings are sufficiently random and hard to\nguess.</p>\n<p style=\"font-weight: normal;\">The sender should delete token during\nthe call to particle.respondTrust to prevent security violations.</p>\n<p style=\"font-weight: normal;\">SenderTokens are one-way. \nSpecifically, the token that Jack uses when sending notifications\nto Jill is different then what Jill uses to send notifications to\nJack.</p><p style=\"font-weight: normal;\">The loginURL arguments are to&#160;accelerate&#160;the process of logging in when viewing a document on another server. &#160;Its purpose is so that a user can click on a link to a document on another server and be automatically logged in. &#160;By directing the user to POST to loginURL with the provided arguments, an OpenID login can be performed without user intervention. &#160;The sending server must redirect the user to the specified loginURLRedirect, which is the URL that the user clicked on, thus giving the illusion of seamless navigation.</p>\n<h1>Sending Notifications</h1><p>After trust is established, a server can send notifications to another server. &#160;When a server sends a notification to\nanother server, the sender uses particle.receiveNotification\nendpoint.  In order to identify the OpenID that sent the notification&#160;the sender uses the\nsenderToken that it obtained when it established trust.  The sender\nmust be prepared to re-establish trust at any time.</p>\n<ol><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">The\n\tsender sends a POST request to the particle.receiveNotification\n\tendpoint.  The following urlencoded arguments are present:</p>\n\t<ol><li><p class=\"numbering-1-western\"><b>senderToken</b><span style=\"font-weight: normal;\">:\n\t\t This is the senderToken established during the calls to\n\t\tparticle.establishTrust and particle.respondTrust.  It identifies\n\t\tthe sender and prohibits spoofing</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>objectUrl</b><span style=\"font-weight: normal;\">:\n\t\t The URL to the document. This value should never change,\n\t\tand is considered the object's unique ID. &#160;It is limited to 500 characters.</span></p></li><li><p class=\"numbering-1-western\"><b>documentType</b><span style=\"font-weight: normal;\">:\n\t\t The document type.  This can be any value under 20 characters. &#160;Like file extensions in a desktop operating system, well-known document types can be established by convention.</span></p><p class=\"numbering-1-western\"><span style=\"font-weight: normal;\">TODO: &#160;Continue here, reformat!!!</span></p></li></ol></li></ol><ol><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">If\n\tthe senderToken is unknown or trust needs to be re-established, then\n\trecipient responds with a 412 (precondition failed.) and the text\n\t\u201csenderToken\u201d.  The sender should use the\n\tprovider.establishTrust endpoint to get a new senderToken, and then\n\tre-send the notification.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">If\n\tthe notification was sent successfully, then the recipient responds\n\twith a 202 (accepted).</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">The\n\terror code 450 (Blocked) is used to indicate that the sender should\n\tstop sending new notifications for the objectUrl.  Recipients should\n\thave additional logic to handle cases where this error code is\n\tignored.  Recipients may choose not to send this and continue to\n\tignore notifications to deleted objects.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Some\n\tdocumentTypes might have additional error codes that need to be\n\treturned to the object initiating the notification.  These are not\n\tpart of Particle's notification protocol.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">The\n\trecipient should block any notifications for objects that do not\n\tcome from the same server as the sender.  If this happens, then the\n\tserver will return a 406 (Not Acceptable.)  The server can also\n\toptionally return a note explaining the error; however, this is\n\toptional.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">The\n\trecipient will unblock any clients that have pending requests on\n\tparticle.getNotifications waiting for updated notifications.</p>\n</li></ol>\n<p style=\"font-weight: normal;\">Notes:</p>\n<p style=\"font-weight: normal;\">For collaborative documents, the\nsender should be the document's owner.  The particle protocol does\nnot include explicit functionality to indicate which user made a\nparticular change to a document; thus the sender will always be the\ndocument's owner instead of who made the modification.</p>\n<p style=\"font-weight: normal;\">Object creation is implicit; that is,\na recipient becomes aware of an object as soon as it gets a\nnotification that has the object's objectUrl as an argument. \nRecipients should store the objectUrl of objects that are deleted,\nthis way they do not become aware of objects again if they continue\nto receive unwanted notifications.</p>\n<p style=\"font-weight: normal;\">Some databases work better when\n\u201cstring\u201d columns are fixed length.  The recommended length for\nmessageSummary is 80 characters.  Senders need to take into\nconsideration that their messageSummary could be truncated if longer\nthen 80 characters.</p><h2 style=\"font-weight: normal;\">Waiting for New Notifications with Comet</h2><p>The particle system allows a client to know exactly when a notification arrives.&#160; This is accomplished with a layer 3 Queuing and Reliable Comet session.&#160; (The Comet Protocol is document at <a target=\"_blank\" title=\"\" href=\"/Docs/Specs/Comet%20Protocol.page\">/Docs/Specs/Comet Protocol.page)</a></p>To wait for incoming notifications, establish a Queuing and Reliable Comet session at the particle.incomingNotificationEvent endpoint.&#160; The server will send each notification as it arrives.&#160; Notifications are sent as JSON objects using the same format as recieveNotification endpoint, except that all columns are always present.<br/><h1 class=\"western\" style=\"font-weight: normal;\">Establishing a\nsession</h1>\n<p style=\"font-weight: normal;\">The particle.establishSession endpoint\nis used to allow a client program to establish a session to display\nnotifications.  This is primarily intended for use with mobile\ndevices and thick clients.  Web-based clients where the Particle\nendpoints reside on the same server as the HTML can use whatever\nsystem they desire for authentication.</p>\n<p style=\"font-weight: normal;\">Future modifications to the protocol\nmight replace this with a more secure means of establishing a\nsession.</p>\n<ol><li><p style=\"font-weight: normal;\">The client program or device\n\tstores the OpenID and password.</p>\n\t</li><li><p style=\"font-weight: normal;\">The client program makes a POST\n\trequest to particle.establishSession with the following urlencoded\n\targument:</p>\n\t<ol><li><p><b>password</b><span style=\"font-weight: normal;\">:  The\n\t\tpassword</span></p>\n\t</li></ol>\n\t</li><li><p style=\"font-weight: normal;\">The http status code 202\n\t(accepted) is returned to indicate that the session was created\n\tsuccessfully.  Any 4xx response indicates some form of error.</p>\n</li></ol>\n<p style=\"font-weight: normal;\">It is assumed that session will be\nmaintained through HTTP cookies.  Therefore, the client program or\ndevice should use an HTTP library that can persist session-level\ncookies.</p>\n<h1 class=\"western\" style=\"font-weight: normal;\">Getting Notifications</h1>\n<p style=\"font-weight: normal;\">The particle.getNotifications endpoint\nallows any client or device to get all notifications or a subset of\nrecent notifications.  Prior to using this endpoint, a session must\nbe established using particle.establishSession or another suitable\ntechnique.</p>\n<p style=\"font-weight: normal;\">All notifications have a notification\nID.  This is an unsigned integer.  The first notification has a low\nID, and each subsequent notification received has one value higher. \nNotification IDs should never be skipped and are immutable.  If a\nnotification is deleted from the database, its ID should never be\nre-used.  The lowest ID is implementation-specific.  Due to\ndeletions, clients should not expect the lowest notificationId to be\n0, 1 or some other constant.</p>\n<p style=\"font-weight: normal;\">There is no highest value of\nnotification ID.  Implementations should be designed such that this\nID can become very large.  64-bit unsigned integers are recommended\nas a minimum size.</p>\n<ol><li><p style=\"font-weight: normal;\">The client sends a GET request to\n\tthe particle.getNotifications endpoint with the following optional\n\turlencoded arguments:</p>\n\t<ol><li><p><b>newestNotificationId</b><span style=\"font-weight: normal;\">:\n\t\t The highest notificationId allowed.</span></p>\n\t\t</li><li><p><b>oldestNotificationId</b><span style=\"font-weight: normal;\">:\n\t\t The lowest notificationId allowed.</span></p>\n\t\t</li><li><p><b>maxNotifications</b><span style=\"font-weight: normal;\">: \n\t\tThe maximum number of notifications that are to be returned.  Older\n\t\tnotifications are filtered out if needed.</span></p>\n\t\t</li><li><p><b>objectUrl</b><span style=\"font-weight: normal;\">:  If\n\t\tpresent, only notifications for the given objectUrl are returned.</span></p>\n\t\t</li><li><p><b>sender</b><span style=\"font-weight: normal;\">:  The\n\t\tsender's OpenId.  If present, only notifications from the OpenID of\n\t\tthe sender are returned.</span></p>\n\t\t</li><li><p><b>desiredValues</b><span style=\"font-weight: normal;\">: \n\t\tComma-separated list of values to return.  If missing, all values\n\t\tfor each notification are returned.  If an unknown value is\n\t\tspecified, it is ignored.</span></p>\n\t\t</li></ol>\n\t</li><li><p style=\"font-weight: normal;\">Notifications are returned in the\n\torder that starts with the newest notification first.</p>\n\t</li><li><p style=\"font-weight: normal;\">If all arguments are omitted,\n\tthen all notifications are returned without changeData.</p>\n\t</li><li><p style=\"font-weight: normal;\">The client is responsible for\n\thandling situations where an object has notifications outside of the\n\trange requested.</p>\n\t</li><li><p style=\"font-weight: normal;\">Upon success, a 200 (OK) status\n\tcode is returned.  The notifications returned are in JSON format.  A\n\tJSON array is used with the newest notification first.  The\n\tfollowing values, except for changeData, are returned, unless\n\tdesiredValues specifies a subset:</p>\n</li></ol>\n<ol><ol><li><p class=\"numbering-1-western\"><b>notificationId</b></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>timeStamp</b><span style=\"font-weight: normal;\">:\n\t\t The exact date/time when the notification was sent.  Represented\n\t\tas the number of milliseconds since January 1st 1970 UTC.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>state</b><span style=\"font-weight: normal;\">:\n\t\t Either read or unread</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>sender</b><span style=\"font-weight: normal;\">:\n\t\t The notification's sender's OpenId.  This value can be omitted if\n\t\tthe sender argument is sent.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>objectUrl</b><span style=\"font-weight: normal;\">:\n\t\t The URL to the document.  Displaying this URL in an iFrame should\n\t\talways work on simpler clients.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>title</b><span style=\"font-weight: normal;\">:\n\t\t The title of the document as of when the notification was sent.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>documentType</b><span style=\"font-weight: normal;\">:\n\t\t The document type.  Some particle clients might be able to provide\n\t\tenhanced capabilities for known document types.  For unknown\n\t\tdocument types, the url will be displayed in an iFrame.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>messageSummary</b><span style=\"font-weight: normal;\">:\n\t\t A summary of the notification that will be displayed in the GUI. \n\t\tExamples include:</span></p>\n\t</li></ol></ol>\n<ul><ul><ul><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tshared a document with you</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tupdated the document</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tadded you to the conversation</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tsaid: \u201c...\u201d</p>\n\t\t</li></ul></ul></ul>\n<ol><ol><li><p class=\"numbering-1-western\"><b>changeData</b><span style=\"font-weight: normal;\">:\n\t\t Only returned if explicitly requested in the desiredData argument.\n\t\t This is because changeData can become burdensomely large.  If\n\t\tblock is set to true, changeData is always included if new\n\t\tnotifications arrive.</span></p>\n\t</li></ol><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Upon\n\tfailure, the server should send a 400-class error.</p>\n</li></ol>\n<h1 class=\"western\" style=\"font-weight: normal;\">Updating a\nNotification's State</h1>\n<p style=\"font-weight: normal;\">The particle.updateNotificationState\nis used to update a notification's state.</p>\n<ol><li><p style=\"font-weight: normal;\">The client sends a POST request\n\tto the particle.updateNotificationState endpoint with the following\n\turlencoded arguments:</p>\n\t<ol><li><p><b>readNotificationIds</b><span style=\"font-weight: normal;\">:\n\t\t Comma-seperated list of notificationIds for notifications to be\n\t\tset to \u201cread\u201d</span></p>\n\t\t</li><li><p><b>unreadNotificationIds</b><span style=\"font-weight: normal;\">:\n\t\t Comma-seperated list of notificationIds for notifications to be\n\t\tset to \u201cread\u201d</span></p>\n\t</li></ol>\n\t</li><li><p style=\"font-weight: normal;\">The server returns with 202\n\t(accepted) or a 4xx if an error occurs.</p>\n\t</li><li><p style=\"font-weight: normal;\">All blocked requests for updates\n\tto notifications are completed.</p>\n</li></ol>\n<h1 class=\"western\" style=\"font-weight: normal;\">Updating an Object's\nState</h1>\n<p style=\"font-weight: normal;\">The particle.updateObjectState is used\nto update a object's state.  The following states are supported:</p>\n<ul><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Ignore  (All\n\tnew notifications to a given object / url are hidden)</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Unignore \n\t(All new notifications to a given object / url are displayed.)</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">Delete (All\n\tnotifications to a given object / url are ignored and currently\n\tsaved ones are deleted.  The sender is asked to discontinue sending\n\tnotifications.)</p>\n\t</li><li><p style=\"margin-bottom: 0in; font-weight: normal;\">SilentDelete\n\t(Same as delete except that the sender isn't asked to discontinue\n\tsending notifications.)</p>\n</li></ul>\n<ol start=\"4\"><li><p style=\"font-weight: normal;\">The client sends a POST request\n\tto the particle.updateObjectState endpoint with the following\n\turlencoded arguments:</p>\n\t<ol><li><p><b>objectId</b></p>\n\t\t</li><li><p><b>objectState</b><span style=\"font-weight: normal;\">: \n\t\tEither \u201cignore\u201d, \u201cunignore\u201d, \u201cdelete\u201d, or\n\t\t\u201csilentDelete\u201d.</span></p>\n\t</li></ol>\n\t</li><li><p style=\"font-weight: normal;\">The server returns with 202\n\t(accepted) or a 4xx if an error occurs.  The 410 (Gone) state is\n\tused if the objectUrl is unknown.</p>\n\t</li><li><p style=\"font-weight: normal;\">All blocked requests for updates\n\tto notifications are completed.</p>\n</li></ol>\n<p style=\"font-weight: normal;\">Some servers might allow\nsilently-deleted objects to become unignored; although this is\nimplementation-dependent.</p>\n<h1 class=\"western\" style=\"font-weight: normal;\">Blocking a user or\ndomain</h1>\n<p>The particle.block endpoint is used to block a user or domain.</p>\n<ol><li><p>A POST request is made to the particle.block endpoint with\n\tthe following urlencoded argument:</p>\n\t<ol><li><p><b>toBlock</b>:  If this is a domain, then all senders from\n\t\tthe given domain are blocked.  If this is a complete OpenID url,\n\t\tthen the specific OpenID is blocked.</p>\n\t</li></ol>\n\t</li><li><p>A 202 (Accepted) is returned if successful, else a 4xx code\n\tis returned to indicate an error.</p>\n</li></ol>\n<h1 class=\"western\" style=\"font-weight: normal;\">Un-Blocking a user or\ndomain</h1>\n<p>The particle.unBlock endpoint is used to un-block a user or\ndomain.</p>\n<ol><li value=\"1\"><p>A POST request is made to the particle.unBlock\n\tendpoint with the following urlencoded argument:</p>\n\t<ol><li><p><b>toUnBlock</b>:  If this is a domain, then all senders\n\t\tfrom the given domain are un-blocked.  If this is a complete OpenID\n\t\turl, then the specific OpenID is un-blocked.</p>\n\t</li></ol>\n\t</li><li><p>A 202 (Accepted) is returned if successful, else a 4xx code\n\tis returned to indicate an error.</p>\n</li></ol>\n<h1 class=\"western\" style=\"font-weight: normal;\">Getting all blocked\nOpenIDs and domains</h1>\n<p style=\"font-weight: normal;\">The particle.getBlocked endpoint is\nused to return data about blocked users and domains.  All blocked\ndomains and endpoints are returned as a single Javascript array with\na 200 (OK) error code.</p>\n<h1 class=\"western\" style=\"font-weight: normal;\">Re-establish Trust</h1>\n<p style=\"font-weight: normal;\">TODO:  Perhaps\nparticle.reEstblishTrust endpoint with POST and urlencoded OpenID\nargument?</p>\n<h1 class=\"western\" style=\"font-weight: normal;\">Client Sending a\nNotification</h1>\n<p style=\"font-weight: normal;\">When a client sends a notification, it\nuses the particle.sendNotification endpoint to instruct its server to\nsend a notification.  This endpoint requires an active session\nbetween the client and the server.</p>\n<ol><li value=\"1\"><p class=\"numbering-1-western\" style=\"font-weight: normal;\">\n\tThe client sends a POST request to the particle.sendNotification\n\tendpoint.  The following urlencoded arguments are present:</p>\n\t<ol><li><p class=\"numbering-1-western\"><b>openId</b><span style=\"font-weight: normal;\">:\n\t\t The openId of the notification's recipient.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>objectUrl</b><span style=\"font-weight: normal;\">:\n\t\t The URL to the document.  Displaying this URL in an iFrame should\n\t\talways work on simpler clients.  This value should never change,\n\t\tand is considered the object's unique ID.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>title</b><span style=\"font-weight: normal;\">:\n\t\t The title of the document.  This is always the newest version of\n\t\tthe target object's title, and can change between notifications.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>documentType</b><span style=\"font-weight: normal;\">:\n\t\t The document type.  Some particle clients might be able to provide\n\t\tenhanced capabilities for known document types.  For unknown\n\t\tdocument types, the url will be displayed in an iFrame.</span></p>\n\t\t</li><li><p class=\"numbering-1-western\"><b>messageSummary</b><span style=\"font-weight: normal;\">:\n\t\t A summary of the notification that will be displayed to the\n\t\trecipient. Examples include:</span></p>\n\t</li></ol>\n</li></ol>\n<ul><ul><ul><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tshared a document with you</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tupdated the document</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tadded you to the conversation</p>\n\t\t\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Sender\n\t\t\tsaid: \u201c...\u201d</p>\n\t\t</li></ul></ul></ul>\n<ol><ol><li><p class=\"numbering-1-western\"><b>changeData</b><span style=\"font-weight: normal;\">:\n\t\t Additional data that describes the change.  This is only utilized\n\t\tif the client recognizes the documentType.  The specific format of\n\t\tchangeData is defined by the documentType.  JSON is recommended,\n\t\talthough any string-based encoding will work.</span></p>\n\t</li></ol><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">The\n\tfollowing optional arguments are supported:</p>\n</li></ol>\n<ul><ul><li><p><b>forceRefreshSenderToken</b><span style=\"font-weight: normal;\">:\n\t\t Forces a refresh of the senderToken, defaults to false.</span></p>\n\t\t</li><li><p><b>forceRefreshEndpoints</b><span style=\"font-weight: normal;\">:\n\t\t Forces a refresh of the endpoints, defaults to false.</span></p>\n\t\t</li><li><p><b>maxRetries</b><span style=\"font-weight: normal;\">:</span></p>\n\t\t</li><li><p><b>transportErrorDelay</b><span style=\"font-weight: normal;\">:\n\t\t The amount of time to wait until retrying if there is some kind of\n\t\ta transport error.</span></p>\n\t</li></ul></ul>\n<ol start=\"3\"><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">A 202\n\t(Accepted) is returned if the notification can be sent, elsewise an\n\terror is returned.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">A 403\n\t(Forbidden) returned indicates that the recipient asked to no longer\n\treceive notifications regarding this object.</p>\n\t</li><li><p class=\"numbering-1-western\" style=\"font-weight: normal;\">Implementations\n\tmay choose to queue notifications and provide various retry\n\tcapabilities in the event of a failure.</p>\n</li></ol>\n<p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">\nNotes:</p>\n<p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">\nNotifications are not guaranteed to be sent.  It is recommended that\nvarious clients and documentTypes utilize two-way notifications to\nverify success and notify the user of errors.  It is also recommended\nthat clients use some kind of visual indicator to show what kind of\ndata hasn't had a confirmation notification.</p><h1>TODO: &#160;Getting OpenID form for posting</h1><p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">Build on top of the WebFinder .well-known convention so that the Notification Viewer can find the destination server's OpenID login form. &#160;It should be something like:</p><p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">When a user wants to open a link to a document that's shared with him or her:</p><p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">Notification viewer (or server) visits a well-known URL on the server that hosts the document that's shared</p><p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">This document lists the URL of the form that's used for OpenID login and the \"name\" of the form item that has the OpenID. &#160;Also notes if WebFinger is supported. &#160;In addition, adds another \"name\" for the URL that the user will be redirected to after logging in.</p><p class=\"numbering-1-western\" style=\"margin-left: 0in; font-weight: normal;\">Instead of being directed to the document that the user clicked on, user is directed to a page that (with some Javascript magic) automatically POSTs to the destination server's login URL. &#160;This allows for nearly seamless viewing of shared documents without the user having to log in all the time everywhere</p>\n"}