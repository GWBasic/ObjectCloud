{"Title":"Notes on Scalability","Contents":"<h1>Scaling to Handle Large Amounts of Data</h1><p>Large amounts of data can be handled by replacing ObjectCloud's use of SQLite and the flat file system with a database that is designed to handle the desired volume of data.&#160; The database must be optimized for reading a writing small amounts of data within an object, as opposed to handling large monolithic objects.&#160; SQL meets the \"small amounts of data\" requirement; but SQL databases aren't known for their ability to scale beyond a small cluster of servers.</p><p>Regarding the implementation, the lowest-layer ObjectCloud.DataAccess.SQLite will need to be replaced and re-wired in with Spring.&#160; The TextHandler and BinaryHandler classes in ObjectCloud.Disk.Filehandlers will need stateless replacements that use the new data store instead of the flat file system.<br/></p><h1>Scaling to Handle Large Amounts of Concurrent Users</h1><p>ObjectCloud's Comet system creates an obstacle to scalability.&#160; Without Comet, all layers of ObjectCloud (with the exception of some caching) are inherently stateless; and thus multiple instances of ObjectCloud could run against a single multi-user database.</p><p>The complexity that Comet introduces is that it creates state in the WebHandler classes; the highest layers of ObjectCloud.&#160; It also introduces two-way connections between the WebHandlers and lower layers, such as the FileHandlers.&#160; Thus, scaling to handling large amounts of concurrent users implies that many ObjectCloud nodes will need to share and distribute state about Comet connections and event listeners.&#160; Another approach is to put some form of a forwarding proxy in front of ObjectCloud that ensures that requests for a particular object always happen on the same node; although care will need to be taken to load-balance the /System/Comet/Multiplexer object.<br/></p>"}