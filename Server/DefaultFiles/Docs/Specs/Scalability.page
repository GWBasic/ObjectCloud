<div>Notes on Scalability</div><h1>Scaling to Handle Large Amounts of Data</h1><p>Large amounts of data can be handled by replacing ObjectCloud's use of SQLite and the flat file system with a database that is designed to handle the desired volume of data.&nbsp; The database must be optimized for reading a writing small amounts of data within an object, as opposed to handling large monolithic objects.&nbsp; SQL meets the "small amounts of data" requirement; but SQL databases aren't known for their ability to scale beyond a small cluster of servers.</p><p>Regarding the implementation, the lowest-layer ObjectCloud.DataAccess.SQLite will need to be replaced and re-wired in with Spring.&nbsp; The TextHandler and BinaryHandler classes in ObjectCloud.Disk.Filehandlers will need stateless replacements that use the new data store instead of the flat file system.<br></p><h1>Scaling to Handle Large Amounts of Concurrent Users</h1><p>ObjectCloud's Comet system creates an obstacle to scalability.&nbsp; Without Comet, all layers of ObjectCloud (with the exception of some caching) are inherently stateless; and thus multiple instances of ObjectCloud could run against a single multi-user database.</p><p>The complexity that Comet introduces is that it creates state in the WebHandler classes; the highest layers of ObjectCloud.&nbsp; It also introduces two-way connections between the WebHandlers and lower layers, such as the FileHandlers.&nbsp; Thus, scaling to handling large amounts of concurrent users implies that many ObjectCloud nodes will need to share and distribute state about Comet connections and event listeners.&nbsp; Another approach is to put some form of a forwarding proxy in front of ObjectCloud that ensures that requests for a particular object always happen on the same node; although care will need to be taken to load-balance the /System/Comet/Multiplexer object.<br></p>