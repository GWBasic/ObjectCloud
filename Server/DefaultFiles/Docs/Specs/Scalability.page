{"Title":"Notes on Scalability","Contents":"\u003Ch1>Scaling to Handle Large Amounts of Data\u003C/h1>\u003Cp>Large amounts of data can be handled by replacing ObjectCloud's use of SQLite and the flat file system with a database that is designed to handle the desired volume of data.&nbsp; The database must be optimized for reading a writing small amounts of data within an object, as opposed to handling large monolithic objects.&nbsp; SQL meets the \"small amounts of data\" requirement; but SQL databases aren't known for their ability to scale beyond a small cluster of servers.\u003C/p>\u003Cp>Regarding the implementation, the lowest-layer ObjectCloud.DataAccess.SQLite will need to be replaced and re-wired in with Spring.&nbsp; The TextHandler and BinaryHandler classes in ObjectCloud.Disk.Filehandlers will need stateless replacements that use the new data store instead of the flat file system.\u003Cbr>\u003C/p>\u003Ch1>Scaling to Handle Large Amounts of Concurrent Users\u003C/h1>\u003Cp>ObjectCloud's Comet system creates an obstacle to scalability.&nbsp; Without Comet, all layers of ObjectCloud (with the exception of some caching) are inherently stateless; and thus multiple instances of ObjectCloud could run against a single multi-user database.\u003C/p>\u003Cp>The complexity that Comet introduces is that it creates state in the WebHandler classes; the highest layers of ObjectCloud.&nbsp; It also introduces two-way connections between the WebHandlers and lower layers, such as the FileHandlers.&nbsp; Thus, scaling to handling large amounts of concurrent users implies that many ObjectCloud nodes will need to share and distribute state about Comet connections and event listeners.&nbsp; Another approach is to put some form of a forwarding proxy in front of ObjectCloud that ensures that requests for a particular object always happen on the same node; although care will need to be taken to load-balance the /System/Comet/Multiplexer object.\u003Cbr>\u003C/p>"}