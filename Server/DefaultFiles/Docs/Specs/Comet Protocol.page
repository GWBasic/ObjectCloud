{"Title":"Comet Protocol","Contents":"<p>There are many approaches to building scalable systems to allow a web server to push data into the browser. &#160;These are collectively referred to as Comet, and often rely on long-polling; a technique where a server delays returning a result's request until data is available. &#160;While systems like Java Applets and Flash allow for arbitrary sockets back to the web server; these don't work well in situations where a strict firewall limits restrict outgoing sockets. &#160;Long-polling does not guarantee accuracy or order of data, nor can it scale when there are multiple entities on the server side sending data to the client.</p><p>The Comet Protocol is a layered approach modeled after traditional networking that attempts to address the needs of two-way communication between the browser and the server.&#160; Its layers allow an application implementer to choose the appropriate networking model for an application.&#160; The Comet Protocol offers optional reliability and ordering.&#160; Multiplexing is optional but recommended.&#160; A single URL in a long-polling loop is used at the lowest level for simplicity in implementation.&#160; Independent implementations can provide proprietary enhancements at lower levels that work around fundamental limitations in HTTP long polling.<br/></p>The Comet Protocol exposes packets instead of streams to the application layer.&#160; This is because it's easier to compose streams from ordered packets, but harder to break a stream into packets.&#160; All data is transmitted in a single JSON object.&#160; This makes The Comet Protocol a natural fit for RPC-style communication, which tends to be more popular then writing networking applications that handle raw sockets.&#160; It is possible to emulate TCP sockets and UDP datagrams through The Comet Protocol, although such functionality isn't built into the protocol.<br/><p>The three layers of the Comet Protocol are:</p><ol><li><span style=\"font-weight: bold;\">Transport</span>:&#160; A thin and standardized real-time message loop that utilizes long-polling.</li><li><span style=\"font-weight: bold;\">Multiplexing</span>:&#160; Emulates multiple transports over a single transport thus allowing multiple server-side data sources to be used through a single transport.&#160; This allows for multiple server-side data sources while conserving the browser's sockets.&#160; Similar to UDP, except that it utilizes a request-to-send, get-data-to-send API.<br/></li><li><span style=\"font-weight: bold;\">Queuing and Reliable</span>:&#160; Allows multiple messages to be sent in an ordered and reliable manner without dealing with the semantics of the real-time message loop.&#160; Similar to TCP, except that it's packet based instead of stream based.</li></ol><h1>Requirements</h1><p>The Comet Protocol was designed to fulfill the following requirements:</p><ol><li><span style=\"font-weight: bold;\">Simple Layers</span>:&#160; A small group of simple layers allows an application developer to choose the most appropriate API given the application's needs; and it allows a server and framework developer to optimize a particular layer while still keeping compatible with existing applications.</li><li><span style=\"font-weight: bold;\">Separation of protocol and diagnostics</span>:&#160; In order to keep implementations simple; diagnostics are Comet Protocol endpoints instead of being built directly into the protocol itself.&#160; This is similar to the well-known applications \"ping\" and \"tracert.\"<br/><span style=\"font-weight: bold;\"></span></li><li><span style=\"font-weight: bold;\">Simple Server-side Requirements</span>:&#160; A firm requirement is that all protocols at all layers minimize variables, endpoint proliferation, and fringe use cases.</li><li><span style=\"font-weight: bold;\">Two-way communication</span>:&#160; The protocol must allow for two-way communication as if there is a TCP-style socket connected.</li><li><span style=\"font-weight: bold;\">Multiplexing</span>:&#160; The protocol must allow for multiple unrelated data sources on the server as a means of conserving the browser's open sockets.<br/></li><li><span style=\"font-weight: bold;\">Discrete Packets</span>:&#160; The protocol must send discrete packets instead of a wire-style byte stream.&#160; This is for the following reasons:</li><ul><li>It is easier to write applications that get a stream of packets, and thus objects, instead of a raw byte stream.</li><li>The lowest-level HTTP transport is optimized for packets instead of streams.</li><li>Streaming bytes can cause poor performance unless the bytes are logically arranged into packets.</li><li>Converting ordered and reliable packets to a <a target=\"_blank\" title=\"\" href=\"http://orbited.org/blog/files/csp.html\">Comet Session Protocol</a>-style stream is trivial.</li><li><a target=\"_blank\" title=\"\" href=\"http://svn.cometd.com/trunk/bayeux/bayeux.html\">Bayeux</a>-style event subscription is trivial when receiving packets.<br/></li></ul></ol><h1>Weaknesses</h1><p>Due to long polling, the Comet Protocol is sensitive to high-latency environments.&#160; Specifically, in a high latency environment, the server may only be able to transmit approximately 4 batches of events per second.&#160; On slow connections, the server may only be able to push a batch of events every second or every other second.&#160; Application designers must decide if this restriction fits into their design requirements.&#160; Future versions of the specification may attempt to address this issue.<br/></p><h1>Influences<br/></h1><p>There are two strong influences in the Comet Protocol's design:<br/></p><ul><li><a target=\"_blank\" title=\"\" href=\"http://orbited.org/blog/files/csp.html\"><span style=\"font-weight: bold;\">Comet Session Protocol</span></a>:&#160; The Comet Session Protocol defines a technique for reliably emulating a TCP socket through HTTP.&#160; It is designed for a variety of server-to-browser transmission techniques, including polling, long polling, forever connections, and iFrame streaming.&#160; It does not define multiplexing; although there are multiplexed implementations built on top of it.&#160; An advantage of Comet Session Protocol is that it guarantees data delivery and order.<br/></li><li><a target=\"_blank\" title=\"\" href=\"http://svn.cometd.com/trunk/bayeux/bayeux.html\"><span style=\"font-weight: bold;\">Bayeux</span></a>:&#160; Bayeux introduces an event subscription model.&#160; An advantage of its subscription model is that it allows a client to subscribe to many event sources on the server without worrying about the semantics of multiplexing.</li></ul><h1>Overview</h1><p>The Comet Protocol incorporates three layers.&#160; These layers progressively introduce complexity in an isolated manner that allows for simplified development at each layer, and that allows an application developer to choose the appropriate approach based on the application's needs.</p><p>There is also an implied 0th layer.&#160; This is the session layer.&#160; It is implied that a server implementing The Comet Protocol will have a technique for establishing a session with the browser, and that such a session is pre-established prior to entering any of the layers defined here.&#160; A popular approach is with some form of a session cookie.</p><p>All layers are exposed in the browser as a Javascript API.&#160; The server is expected to place compatible Javascript in a well-known location, although it may expose these layers using whatever semantics are appropriate for its server-side environment.&#160; The server may also implement proprietary enhanced versions of lower-level protocols while still remaining compatible with higher-level protocols.<br/></p><p>The layers in the Comet Protocol Are as follows:<br/></p><ol><li><span style=\"font-weight: bold;\">Transport</span>:&#160; The transport layer is a thin wrapper for traditional AJAX polling and long polling.&#160; It is event-driven, does not guarantee reliability, and does not queue.&#160; The client (browser) tunes long-polling based on aborted HTTP requests, and the server tracks outstanding long-polled requests.&#160; It is recommended that there is only a single transport polling loop running per tab or window; in most cases, it is more appropriate to use the multiplexing layer.&#160; The API is a request-to-send -&gt; ready-to-send model.<br/></li><li><span style=\"font-weight: bold;\">Multiplexing</span>:&#160; The multiplexing layer allows for the Comet Protocol to work with multiple data sources.&#160; In the browser, it exposes the same API as the Transport layer; therefore, Javascript written against the transport layer should also work against the multiplexing layer.&#160; In most cases, this is the lowest layer exposed to the browser.&#160; The multiplexing layer is best suited for applications that send live, rapidly-changing, and lossy data.&#160; This is because both the multiplexing and transport layers expose when they are sending data through the wire; thus allowing an application to transmit the most up-to-date version of data.&#160; This protocol is closest to UDP in that it is unreliable and closest to real-time.<br/></li><li><span style=\"font-weight: bold;\">Queuing and Reliable</span>:&#160; The queuing and reliable layer lets the client or server send packets without handling the event loops of the transport or multiplexing layer.&#160; Packets are guaranteed to be sent to the recipient, and are sent in order.&#160; It is most similar to TCP, except that it uses packets and does not require the recipient to re-construct any framing.<br/></li></ol><h1>Recommended Script Locations, Endpoints, and Conventions<br/></h1><p>In order to guarantee portability among servers implementing The Comet Protocol, the following recommendations exist:</p><h2>Javascript Locations:</h2><p>All Javascript needed to access layer 2 (multiplexing) and 3 (queuing and reliable) should be located at:</p><pre style=\"margin-left: 40px;\">/API/Comet/CometProtocol.js<br/></pre><p>In addition, All Javascript needed to access layer 1 (transport) should be located at:</p><pre style=\"margin-left: 40px;\">/API/Comet/CometTransport.js<br/></pre><p>The reason for this separation is to allow servers to implement custom performance improvements on the base transport layer, yet still keep a compatible, well-known, and established Comet Protocol stack.&#160; For example, a server could implement a custom version of CometTransport.js that attempts to use Flash's XmlSocket.&#160; This would greatly improve performance without needing to re-write layers 2 and 3.<br/></p><p>It is recommended that the server use HTTP headers to instruct the\nbrowser to cache these Javascript files for a very long time.&#160; Dynamic loading\nof dependencies is discouraged due to performance implications.&#160; The server may optionally minimize the Javascript.</p><h2>Endpoints and Conventions</h2><p>It is recommended that the default multiplexer URL is at the following path:</p><pre style=\"margin-left: 40px;\">/System/Comet/Multiplexer<br/></pre><p>On the server, the Multiplexer should emulate the APIs that the transport layer uses.&#160; Thus, when a URL receives a connection on the server, it doesn't know if the connection is coming from a raw transport layer or a multiplexed transport layer.&#160; Likewise, in the browser, the Multiplexer should use the same paths that are in URLs.</p><p>It is recommended that a default loopback is at the following path:</p>\n<pre style=\"margin-left: 40px;\">/System/Comet/Loopback<br/></pre>\n<p>The loopback transport sends a packet of information every 10\nseconds, starting as soon as a connection is made.&#160; This information is\na JSON object with two values:</p><ul><li><span style=\"font-weight: bold;\">ts</span>:&#160; The local time at the server as a human-readable string.</li><li><span style=\"font-weight: bold;\">d</span>:&#160; The most recent data that the client sent.<br/></li></ul><p>It is recommended that a default echo is at the following path:</p>\n<pre style=\"margin-left: 40px;\">/System/Comet/Echo<br/></pre>\n<p>The echo transport returns the same packet that is sent, as soon as the packet is received.&#160; It is useful for timing latency between the client and server.</p><span style=\"font-weight: bold;\"></span><h1>Layer Implementations<br/></h1><p>This section describes how all layers are implemented, and the Javascript APIs exposed to the browser.</p><h2>Layer 0:&#160; Session</h2><p>The session layer is implied.&#160; Specifically, the server must automatically establish a session between the browser and itself.&#160; Session management is not part of the Comet Protocol, although a recommended approach is to use Cookies.<br/></p><h2>Layer 1:&#160; Transport</h2><p>The transport layer is the only layer that deals directly with HTTP and AJAX.&#160; It establishes a long-polling loop between a browser's tab/window and the server.&#160; The time line of the transport layer is as follows:</p><p style=\"margin-left: 40px;\">Client-side Javascript:</p><pre style=\"margin-left: 80px;\">var transport = CP_Transport.create(<br/>   \"http://myserver:123/the/path/on/server\",<br/>   {<br/>      getDataToSend: function(sendId) { },<br/>      handleIncomingData: function(incoming) { },<br/>      handleError: function(error) { },<br/>      flashSuccess: function(transport, sendId) { },<br/>      flashError: function(transport, sendId) { }<br/>   });<br/></pre><p style=\"margin-left: 120px;\">The create function performs two tasks; generate a transport ID and return an object with additional functions needed to send data.&#160; The transport ID must be a positive integer and unique among all windows and tabs sharing the same session on the server.&#160; There is no need to worry about collisions from other sessions because the server automatically establishes a session and separates transports by their session.&#160; Random numbers are recommended, but not required.<br/></p><p style=\"margin-left: 120px;\">The Create function does not open any AJAX requests to the server.</p><p style=\"margin-left: 0px;\"></p><pre style=\"margin-left: 80px;\">transport.startSend(100);<br/></pre><p style=\"margin-left: 120px;\">The startSend function starts the process of sending data from the client to the server.&#160; Its only argument is how long to wait before sending data, specified in milliseconds.&#160; Multiple calls can be made to startSend with shorter delays, and the shortest delay will be used.&#160; StartSend with a delay of 0 will result in an immediate send.</p><p style=\"margin-left: 160px;\"><span style=\"font-weight: bold;\">Note</span>:&#160; <span style=\"font-style: italic;\">A delay of 0 is not recommended in multiplexed situations.&#160; In addition, short delays on busy transports can introduce performance bottlenecks due to HTTP overhead.&#160; In keeping with the spirit of <a target=\"_blank\" title=\"\" href=\"http://en.wikipedia.org/wiki/Nagle_algorithm\">Nagle's Algorithm</a>, the default delay is 200 milliseconds.</span><br/></p><pre style=\"margin-left: 80px;\">getDataToSend(sendId)<br/></pre><p style=\"margin-left: 120px;\">After startSend's delay, the transport calls the getDataToSend function.&#160; It can return any Javascript data\ntype, including strings, numbers, booleans, objects, arrays, and null.&#160;\nNull is recommended if there is no data to send.</p><p style=\"margin-left: 160px;\"><span style=\"font-weight: bold;\">Note</span>:&#160; <span style=\"font-style: italic;\">getDataToSend can be called even if you haven't called startSend.&#160; This will happen when the server returns data.</span><br/></p><p style=\"margin-left: 120px;\">The transport then sends a POST request to the url passed in to the create function.&#160; Minimal headers should be used, as all communication is through the POST body.&#160; The POST body is a single JSON-encoded object with the following values:</p><ul><ul><ul><ul><li><span style=\"font-weight: bold;\">tid</span>:&#160; The transport ID, any integer number.<br/></li><li><span style=\"font-weight: bold;\">isNew</span>:&#160; Only present during the first POST request for a given transport ID, always set to true.</li><li><span style=\"font-weight: bold;\">lp</span>:&#160; The length of time to long-poll, in milliseconds.&#160; For the first POST request, this should be no more then 3 seconds.</li><li><span style=\"font-weight: bold;\">d</span>:&#160; The data from the call to getDataToSend.&#160; This is not re-encoded, re-JSONed, ect.&#160; This is absent if getDataToSend returned null.<br/></li></ul></ul></ul></ul><p style=\"margin-left: 120px;\">The sendId is an integer identifier that is unique for the connection.&#160; The client-side Javascript can use the sendId to determine if data was sent correctly or not.<br/></p><p style=\"margin-left: 40px;\">Server-Side POST handler:</p><p style=\"margin-left: 80px;\">On the server side, the JSON-encoded POST body is decoded.</p><div style=\"margin-left: 80px;\">If \"isNew\" is present, and the session already has an ongoing transport with the same transport ID, an HTTP 409 (Conflict) is returned.&#160; If \"isNew\" is present with a new transport ID, the server internally creates a transport for the given session with a transport ID.&#160; When establishing a transport on the server-side, whatever server-side module that obtains the transport must:</div><ul><ul><ul><li>get a transport object that has the equivalent of a \"startSend\" function.</li><li>provide getDataToSend() and handleIncomingData() equivalent callbacks.<br/></li></ul></ul></ul><p style=\"margin-left: 80px;\">If \"new\" is not present, and the session doesn't have an ongoing transport with the same transport ID, an HTTP 410 (Gone) is returned.</p><p style=\"margin-left: 80px;\">Bad requests and any error condition not anticipated in the specification result in a 400 (Bad Request) error.</p><p style=\"margin-left: 80px;\">If \"d\" is present, its contents are passed to the server-side handleIncomingData equivalent callback.<br/></p><p style=\"margin-left: 80px;\">The server then holds on to the open HTTP request until one of the following conditions is met:</p><ul><ul><ul><li>The long-poll timespan specified in \"lp\" expires</li><li>The server-side version of \"startSend\" is called</li><li>Another incoming request for the same session and transport ID comes in.<br/></li></ul></ul></ul><p style=\"margin-left: 80px;\">When its ready to end the long-poll, it calls the server-side getDataToSend.&#160; If there is data to return, then the content portion of the HTTP response is the JSON-encoded results of getDataToSend.&#160; No data (Content-length 0) is used to communicate that there was no data to return.&#160; The HTTP status code is 200 (OK)</p><p style=\"margin-left: 120px;\"><span style=\"font-weight: bold;\">Note</span>:&#160; <span style=\"font-style: italic;\">The server must guarantee that there is no malicious Javascript in the JSON it returns.</span><br/></p><p style=\"margin-left: 40px;\">Client-side Javascript:</p><p style=\"margin-left: 80px;\">If an HTTP 409 (Conflict) is returned, the client generates a new transport ID and behaves as if startSend(0) is called.</p><p style=\"margin-left: 80px;\">If an HTTP 410 (Gone) is returned, or any other 4xx or 5xx is returned, the client calls the handleError callback.&#160; At this point, all calls to startSend should generate an exception.<br/></p><p style=\"margin-left: 80px;\">If the server returned an HTTP 200 (OK), flashSuccess is called.&#160; If data was transmitted from the server, it will be evaled and passed to the handleIncomingData callback.&#160; If there are no open requests requests from the client to the server, the client will then call startSend with a 0-millisecond delay.</p><p style=\"margin-left: 80px;\">If there is any other status code, or a transport error, then the long polling value is set back to 1 second, flashError is called, and the transport behaves as if startSend(2500) is called.<br/></p><p>The client and server must always call their startSend functions whenever data is ready to send; and they must anticipate that their getDataToSend functions will be called when there isn't data to send.&#160; Likewise, they must anticipate that startSend could be called multiple times before getDataToSend is called.<br/></p><p>The Transport layer does not have an explicit way to close.&#160; This is because it is anticipated to be on-going while a window or tab is open, and stopped without an opportunity to gracefully shut down.&#160; The server should discard transports that are idle (no incoming HTTP requests) for more then five minutes.</p><p>The flashSuccess and flashError functions allow an application to be aware of the transport's status.&#160; Both functions are passed the AJAX status callback object and the sendId used for the original getDataToSend request.&#160; The flash callbacks allow feedback on the success or failure of sending data, and a visible communication that a connection is valid or that there is a temporary disconnection.&#160; In the event of flashError being called and the recipient desires a sooner re-try, call startSend and re-return the data from getDataToSend.</p><p>There is no limit to the amount of requests that the client can open to the server; although the server must only keep a single long poll open.&#160; Future versions of the specification may allow the server to hold multiple long polls open.<br/></p><h2><span style=\"font-weight: bold;\"></span>Layer 2:&#160; Multiplexing</h2><p>Multiplexing sits directly on top of the transport layer and allows multiple services to use the transport without hitting browser limits with regard to open HTTP connections while long-polling.</p><p>The multiplexer works strictly through the data sent over the Transport layer.&#160; It always sends and receives JSON-encoded objects.</p><p>Unlike when establishing a transport, full URLs can not be used.&#160; Only paths can be used.&#160; Some server implementations may only expose certain services at the multiplexing level, although server implementations should allow services that are exposed at the transport level to also work at the multiplexing level.<br/></p><p>Data sent from the client looks like the following:</p><div style=\"margin-left: 40px;\"><pre>\"d\" : {<br/>   \"m\": [ // array of control commands ],<br/>  &#160;\"0\": // Data sent that's multiplexed on channel 0,<br/>  &#160;\"1\": // Data sent that's multiplexed on channel 1,<br/>  &#160;\"2\": // Data sent that's multiplexed on channel 2<br/>}</pre></div><p>If a channel is not present, it means that the channel does not have data for this part of the loop.<br/></p><p>Data returned from the server looks like the following:</p>\n<div style=\"margin-left: 40px;\">\n<pre>{<br/>   \"m\": [ // array of control commands ],<br/>  &#160;\"0\": // Data sent that's multiplexed on channel 0,<br/>  &#160;\"1\": // Data sent that's multiplexed on channel 1,<br/>  &#160;\"2\": // Data sent that's multiplexed on channel 2<br/>}</pre>\n</div>\n<p>If a channel is not present, it means that the channel does not have data for this part of the loop.<br/>\n</p>\n<p>A client establishes a sub-transport through the multiplexed transport by including the URLs of the endpoints in the \"m\" part of its array.&#160; It must also include a transport ID for each multiplexed comet session; this is to allow multiple communication streams to the same endpoint.&#160; The transportID must be unique for the multiplexed transport.&#160; The \"m\" portion is only present if there is control information.&#160; Data for each transport can be sent, but due to the unreliable nature of both the transport and multiplexed layers, it may be lost:</p><div style=\"margin-left: 40px;\">\n<pre>\"d\": {<br/>   \"m\": <br/>   [<br/>      { \"u\": \"/chatrooms/c1\", \"tid\": 123 },<br/>      { \"u\": \"/friendwatchers/myfriends\", \"tid\": 456 },<br/>     &#160;{ \"u\": \"/tickers/stock\", \"tid\": 789 },<br/>&#160;     { \"u\": \"/doesnotexist\", \"tid\": 275 }<br/>  &#160;]<br/>   \"456\": \"data...\",<br/>   \"275\": \"data...\"<br/>}</pre>\n</div>\n<p>The server responds with a JSON object that contains acks and errors in the \"m\" part of its object, and data.&#160; Each multiplexed channel's data is identified as a property named after the channel's tid.&#160; The \"m\" part of the object contains an array at element a that is all acked tids.&#160; The \"m\" part also contains error codes indexed as the tid.&#160; The \"m\" portion is only present if there is control information.<br/></p>{<br/><div style=\"margin-left: 40px;\"><pre>   \"m\": <br/>   {<br/>      \"a\": [123,456,789],<br/>      \"257\": 404<br/>  &#160;},<br/>  &#160;\"123\": \"data..\",<br/>  &#160;\"456\": \"data...\",<br/>  &#160;\"789\": \"data...\"<br/>}</pre>\n</div>\n\n<p>Due to the unreliable nature of the transport, the client should continue to initiate connections in the \"m\" array until it gets a response that assigns it a channel; likewise, the server should continue to use the same ID for a url in case a response is lost.&#160; Channels live as long as the transport lives, so there is no way to destroy a channel.<br/></p><div style=\"margin-left: 40px;\"><p>Client-side Javascript:</p><p>When establishing a transport that runs through a common multiplexer for a tab or window, call:<br/></p></div><pre style=\"margin-left: 80px;\">var transport = CP_Mulitplex.create(<br/>   \"/the/path/on/server\",<br/>   {<br/>      getDataToSend: function(sendId) { },<br/>      handleIncomingData: function(incoming) { },<br/>      handleError: function(error) { },<br/>      flashSuccess: function(transport, sendId) { },<br/>      flashError: function(transport, sendId) { }<br/>   });</pre><p style=\"margin-left: 80px;\">The create function will either use an existing multiplexer or create one using the following Javascript:<br/></p><pre style=\"margin-left: 80px;\">var multiplexerTransport = CP_Transport.create(<br/>   \"/System/Comet/Multiplexer\",<br/>   {<br/>      getDataToSend: function() { },<br/>      handleIncomingData: function(var incoming) { },<br/>      handleError: function(var error) { }<br/>   });</pre>\n<pre style=\"margin-left: 80px;\">var defaultMultiplexer = CP_Multiplex.createFromTransport(muliplexerTransport);<br/></pre><p style=\"margin-left: 120px;\"><span style=\"font-weight: bold;\">Note</span>:&#160; <span style=\"font-style: italic;\">Both the create and createFromTransport functions must be available to client-side Javascript, although it is recommended that the create function is used instead of directly creating a multiplexer.</span><br/></p><p style=\"margin-left: 80px;\">The call to CP_Multiplex.create calls defaultMultiplexer.create which returns an object with the same API as a layer 1 transport.&#160; It has the following behavior:<br/></p><ul><ul><ul><li>A call to startSend from anyone using the multiplexed transport calls the base startSend.</li><li>When the multiplexed transport's getDataToSend is called, it calls everyone's getDataToSend.</li><li>When the multiplexed transport's handleIncomingData is called, it calls everyone's handleIncomingData if they have data present.</li><li>When the multiplexed transport's handleError is called, it calls everyone's handleError.<br/></li></ul></ul></ul><p>The flashSuccess and flashError functions behave exactly like the Transport layer.</p><p style=\"margin-left: 40px;\">In some cases, if an error occurs, it may be desirable to reset the underlying transport.&#160; This can be performed by calling:<br/></p><pre style=\"margin-left: 80px;\">CP_Multiplex.reset();<br/></pre><p style=\"margin-left: 40px;\">The CP_Multiplex function sets defaultMultiplexer to null, effectively forcing creation of a new transport when the next call is made to CP_Multiple.create.&#160; While this is useful if an error condition destroys the underlying transport; it can also enable some channels to have their own isolated sockets.<br/></p><h2>Layer 3:&#160; Queuing and Reliable<br/></h2><p>The queuing and reliable (q&amp;r) layer completely shields the application programmer from the long-polling and unreliable nature of both the transport and multiplexing layers.&#160; The q&amp;r layer allows a Javascript application to progressively pass objects to a function and be assured that such objects will be sent.&#160; When sending data, the q&amp;r layer stores the sendId given to getDataToSend.&#160; It then considers the data successfully sent when its flashSuccess callback is passed the same sendId.&#160; Likewise, the q&amp;r layer allows the server to send a reliable and ordered stream of objects.&#160; It relies on the client-side part of the layer to include an \"ack\" as soon as its getDataToSend is called.&#160; This implies that, as soon as a long-poll with q&amp;r data returns to the browser, the next AJAX request will include \"ack\" data.</p><p>The data that the client sends to the server is a JSON object with an \"a\" property that contains the highest known packet ID, and a \"d\" property that contains each packet.&#160; The \"d\" property is an object where each packet is a property named by the packet's ID, and the value is any valid JSON object.&#160; Sent packet IDs must begin with 0, incement by 1, and be unique within the connection.</p><p>The purpose of packet IDs in sent packets it in case a server processes incoming packets, but its response to the originating HTTP POST request is lost.&#160; In such a scenario, the client will send duplicate packets and the server needs to know which packets to ignore.<br/></p><p>For example:</p><pre style=\"margin-left: 40px;\">{<br/>   \"a\": 32,<br/>   \"d\":<br/>   {<br/>      \"7\": \"data...\",<br/>      \"8\": true,<br/>      \"9\": 123,<br/>      \"10\": {\"a\": \"property a\", \"b\": \"property b\"}<br/>   }<br/>}<br/></pre><p>Whenever the server's equivalent of getDataToSend is called, all unacked packets will be sent.&#160; This implies that there will be no long-polls outstanding while there are unacked packets.&#160; The data sent is as a single object with each packet as a property.&#160; Like when the client sends data, each property's name is the packet ID and the value is any valid JSON object.<br/></p><p>For example, assuming that the highest acked packet is 32:<br/></p><pre style=\"margin-left: 40px;\">{<br/>   \"33\": \"more data\",<br/>   \"34\": 456,<br/>   \"35\": true<br/>}<br/></pre><p>To end a connection, the client side of the q&amp;r layer must wait until it's successfully verified that all data was sent.&#160; Once all data is sent, it must send a single object with a property named \"end\" and a value of true.&#160; It must include an ack in the end packet, and keep sending the end packet until it gets an end packet from the server.&#160; (The server end packet is described next.)&#160; The client must continue to process and ack incoming data until it gets an end packet from the server and has a call to its flashSuccess with the same sendId that was used for an end packet.</p><p>The client must never transmit packets containing data with an end packet.<br/></p>For example:<br/><pre style=\"margin-left: 40px;\">{\"a\": 128, \"end\": true}<br/></pre><p><span style=\"background-color: rgb(255, 255, 255);\">When the server recieves an \"end\" packet, it must send all unacked packets and continue to send all unacked packets until it recieves an end packet with the appropriate ack ID.</span>&#160; The server indicates that it's ready to end a connection by including a property named \"end\" in the object that it sends.<br/></p><pre style=\"margin-left: 40px;\">{<br/>   \"129\": 6543,<br/>   \"130\": \"abc\",<br/>   \"end\": true<br/>}<br/></pre><p>In the above example, the server will continue to re-send packets until it gets a packet from the client that looks like:</p><pre style=\"margin-left: 40px;\">{<span style=\"background-color: rgb(255, 255, 0);\">\"a\": 130</span>, \"end\": true}</pre><p>The server may end a connection by including an end packet.&#160; It can not consider the connection complete until it receives an end packet from the client and all sent packets are acked.&#160; Due to the unreliable nature of the underlying transport; both the server and client may imply that a connection is closed if no response to an end packet comes after 60 seconds have passed, although an error must be given through the API.</p><p>Neither the client or server may send additional new packets after sending an end packet.&#160; Both the client and server must throw an exception if an attempt is made to send data after they send an end packet.<br/></p><p>Javascript API:</p><p style=\"margin-left: 40px;\">To initiate a q&amp;r connection over the default multiplexer, call:</p><pre style=\"margin-left: 80px;\">var socket = CP_QualityReliable.connect(<br/>   \"/the/endpoint\"<br/>   {<br/>      handleIncomingData: function(incoming, packetId) { },<br/>      handleCloseRequested: function() { },<br/>      handleClosed: function() { },<br/>      handleError: function(error) { },<br/>      flashSuccess: function(transport, sendId) { },<br/>      flashError: function(transport, sendId) { }<br/>   });<br/></pre><p style=\"margin-left: 40px;\">The handleIncomingData is called whenever there is incoming data.&#160; The packetId is also included.&#160; HandleIncomingData is always called in the proper order as communicated through the packetId.&#160; The handleCloseRequest is called whenever the server requests to close the q&amp;r session.&#160; The handleClosed callback is used when the q&amp;r transport is completely closed, and is called both when the server requests to close the q&amp;r session and when the client requests to close the q&amp;r session.&#160; The handleError callback is called whenever the underlying transport has an unrecoverable error, or if the q&amp;r connection is closed in error.&#160; FlashSuccess and FlashFailure behave like all of the other layers and are used to communicate the status of the underlying transport.</p><p style=\"margin-left: 40px;\">All of the client-side callbacks are optional.</p><p style=\"margin-left: 40px;\">The returned q&amp;r connection object has the following functions:</p><pre style=\"margin-left: 80px;\">send(data, maxDelay);<br/></pre><p style=\"margin-left: 40px;\">The send function queues the data object to send.&#160; The data object must be serializable to valid JSON.&#160; MaxDelay is an optional argument and defaults to 50.&#160; It is a time span, in milliseconds, of how long to wait for additional data before sending the data to the server.&#160; Larger delays are useful when sending many small objects in succession; however, smaller delays are useful when it is known that only a single object will be sent or when all objects can be sent immediately.</p><p style=\"margin-left: 40px;\">Send will throw an exception if either the client or server has initiated closing the connection.<br/></p><pre style=\"margin-left: 80px;\">close();<br/></pre><p style=\"margin-left: 40px;\">The close function initiates closing the q&amp;r connection.<br/></p><p>The server API should attempt to emulate the client API as closely as possible.<br/></p><h1>Additional Notes and Functionality</h1><p>Many browsers have varying limits on the amount of open sockets that they allow to a particular web server. &#160;A shortcoming in The Comet Protocol is that if too many pages or tabs have an active Comet Transport, the browser may become unresponsive due to all long polls blocking new pages.</p><p>To work around this issue, servers are&#160;recommended&#160;to close old Comet Transports when a session's number of open comet transports exceeds a configurable number.</p><h1>Future Functionality</h1><p>Future versions of the Comet Protocol may introduce additional optional features at the Transport layer in an attempt to lower latency when transmitting many packets from the server.&#160; These features may include:</p><ul><li><span style=\"font-weight: bold;\">Flash or Java Applet Socket Support</span>:&#160; A potential technique to reduce latency is to utilize Flash or a Java Applet to open a socket on the original server.&#160; This would fall back to the original Transport spec if access to a special outgoing socket is limited by a strict network policy.</li><li><span style=\"font-weight: bold;\">\"forever connections\"</span>:&#160; Some browsers may support \"forever connections,\" which allows the server to transmit data with lower latency.&#160; If the browser does not support this, fallback to long-polling would occur.<br/></li><li><b>Connection Sharing through Cookies:</b>&#160;&#160;In some browsers, Comet can cause problems when multiple tabs are open. &#160;An approach to address this is to use local cookies to share a single long-poll among tabs. &#160;The appropriate place to implement this is in the multiplexing layer. &#160;(layer 2)</li></ul><br/><p><br/></p><br/>"}