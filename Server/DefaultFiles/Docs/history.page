<div>History and Direction of ObjectCloud</div>
<p><a href="about.page" style="color: rgb(68, 68, 119); ">About ObjectCloud</a><br></p><p>Andrew Rondeau started ObjectCloud in November 2008, and transitioned to full-time work on ObjectCloud in late July 2009. &nbsp;Currently Andrew is building commercial applications with ObjectCloud. &nbsp;This page describes the history of ObjectCloud by describing initial goals, philosophy, and design&nbsp;decisions.</p><h1>Prior to ObjectCloud</h1><p>Prior to ObjectCloud, Andrew worked on a few different web applications that laid a foundation for inspiring ObjectCloud's design.<br></p><h2>Memmexx (2006-2007)</h2><p>The inspiration for Memmexx came from a design challenge that Andrew posed: &nbsp;"What is the first web site that I'd want to visit when I open the browser?" &nbsp;Memmexx's goal was to pull together bookmarking, history, and web applications into a central starting point as a home page. &nbsp;It then extended into a custom Windows shell that made web applications appear like desktop applications in a manner similar to Firefox's&nbsp;Prism. &nbsp;This shell&nbsp;synchronized&nbsp;itself among all computers that the user used; thus allowing the user to seamlessly use many computing devices without needing to manually maintain each device.</p><p>Steve Wozniak inspired Memmexx's core lesson: &nbsp;"Stay close to the metal." &nbsp;Andrew initially tried implementing Memmexx in ASP.Net, but quit because ASP.Net put too many layers over how the web really works. &nbsp;Andrew chose to write his own web server technology for after listening to Steve Wozniak speak about how good technology development requires that the developer stay "close to the metal" when creating technology. &nbsp;Upon listening to Woz speak about how too many abstractions can get in the way, Andrew realized that he could be&nbsp;successful&nbsp;with Memmexx if he created his own web server technology instead of working around&nbsp;poor abstractions in ASP.Net and Apache. &nbsp;This&nbsp;influenced&nbsp;Andrew's&nbsp;decision&nbsp;to implement ObjectCloud as its own web server instead of working with the limitations of existing web development technologies and frameworks.</p><p>Another lesson from Memmexx that Andrew learned is that privacy is a real concern of end users. &nbsp;Andrew found that a vocal group of end users want real control over their data. &nbsp;This influenced his&nbsp;decision&nbsp;to design ObjectCloud in such a way that the end user can host his or her instance, if desired.</p><p>Andrew decided not to open Memmexx to the public because a feature within the system had a security flaw that would require some significant work to mitigate. &nbsp;Instead of opening Memmexx to the public, Andrew decided to concentrate on learning how to write desktop-like web-based applications.</p><h2>GearPod (2007)</h2><p>GearPod was an attempt to use two new Google web development technologies, GWT and Google Gears, to create a desktop-like application. &nbsp;The <a href="http://andrewrondeau.com/com.Memmexx.GearPod/GearPod.html" title="" target="_blank">first version of GearPod</a> was a proof-of-concept web-based MP3 player that had a few MP3s hardcoded into the library. &nbsp;It takes on the&nbsp;appearance&nbsp;of music players like Windows Media Player and WinAmp.</p><p>Later in 2007, Andrew re-wrote GearPod to include an MP3 search engine and drag-and-drop playlist generation. &nbsp;The search engine operated by scraping Google and other MP3 search sites. &nbsp;This version was well-received&nbsp;by people that Andrew showed it to, although never opened to the public due to fear of a lawsuit. &nbsp;(SeeqPod, a similar commercial site, was sued in January 2008.) &nbsp;Andrew originally used Apache and PHP for GearPod's backend, although he later ported the backend to run on the Memmexx web server technology for convenience reasons. &nbsp;In the long run,&nbsp;scraping other search engines to find MP3s proved fragile; thus GearPod with search no longer works.</p><h2>Asumaku (2008)</h2><p>After GearPod and some other projects, Andrew decided that he wanted to develop something fun and socially interactive. &nbsp;Asumaku was an attempt to let anyone add a comment or discussion about any web site, and then later, any search. &nbsp;The Asumaku system displayed a chat system in one frame, and a web site (or search results) in another frame. &nbsp;The eventual goal was to allow people who were searching for similar things to "bump into each other" and interact with each other.<br></p><div><p>Andrew originally used Apache and PHP for Asumaku's backend, although he later ported the backend to run on the Memmexx web server technology. &nbsp;Porting Asumaku was a lesson in itself; most commodity web hosting companies didn't not allow any form of chat sites due to the large load that the put onto Apache.&nbsp;&nbsp;This is because, at the time, the typical LAMP stack wasn't designed around supporting comet style applications.&nbsp;&nbsp;Thus, Asumaku was ported to Memmexx out of economic&nbsp;necessity.</p></div><h2>Lessons Learned</h2><div><ol><li><b>Privacy and openness is important:</b>&nbsp;&nbsp;A vocal minority of users will need to host their own data. &nbsp;In order to succeed, trust between the user and the software developer must be mutual; sometimes the user will need to trust the software developer or a third party with his/her data; and in other cases, the software developer will need to trust that the user doesn't pirate the software.</li><li><b>True innovation requires comfort working "close to the metal":</b>&nbsp;&nbsp;The major web server development platforms, Apache and ASP.Net; and their frameworks, have limitations in their abstractions that can get in the way of innovation. &nbsp;In order to truly innovate on the web, one must be comfortable programming at the lowest levels.</li><li><b>The web can replace the desktop:</b>&nbsp;&nbsp;Provided that the right backend is present, technologies like HTML, Javascript, and Flash can create portable applications that rival desktop applications yet transcend the barriers of a single physical machine.</li><li><b>3rd Party Services are inherently unreliable</b>: &nbsp;3rd parties can change their APIs or data representations at any time, thus breaking systems that depend on them. &nbsp;Reliance on 3rd parties must be at the&nbsp;peripheries&nbsp;of a system and alternatives must be readily available.</li></ol><h1>Inspiration</h1></div><p>ObjectCloud grew out of an idea that Andrew had for Memmexx called WebDOS. &nbsp;Essentially, WebDOS would be a central location for all of a Memmexx user's documents, and would allow accessing these documents from any internet-connected device, such as a mobile phone. &nbsp;This idea was re-incarnated when Andrew met Walter Roth, and Walter showed Andrew a product named Spoxel. &nbsp;Spoxel was an online file browser that allowed&nbsp;hierarchal&nbsp;navigation and online document editing. &nbsp;The moment of inspiration was when Andrew realized that web-based operating system replacements like Spoxel could only be successful if they were self-describing; that is, as much as the system as possible needed to be written and programmed in the system itself. &nbsp;This essentially means that web-based file systems need to have a significant majority of their business and presentation logic declared in the same file system that user data is stored in.<br></p><p>This is how Windows, MacOS, and Linux are created. &nbsp;With the exception of the boot sector; all desktop operating systems store the complete operating system and applications in the user-visible file system; as opposed to hiding it like conventional web applications do.<br></p><h1>Initial Philosophy and Design Constraints</h1><p>Andrew initially called ObjectCloud "WebDOS." &nbsp;The philosophy was to build web applications using the same design approach that one uses when building a desktop application. &nbsp;The web server would be designed just like an operating system, provide a file I/O API in Javascript through AJAX, and enforce user permissions for security. &nbsp;It would contain files and directories that map directly with the URL; that is, "http://myserver.com/myfolder" would be a user-manipulatable folder. &nbsp;Theoretically, the core of the server would only be smart enough to serve just enough HTML, Javascript, and images so that the application would load in the browser and handle all needed logic.</p><p>Some additional experimental pieces were added. &nbsp;Andrew decided to use SQLite to manage the file system's metadata, and to manage the user database. &nbsp;SQLite was chosen to keep deployment and development simple; yet the server was architected so that a better performing database could be utilized in the future if needed. &nbsp;Andrew initially started ObjectCloud (as WebDOS) in Java, but he quickly grew frustrated with Java's inabilities to express queries that could be translated to SQL. &nbsp;He ported the early WebDOS code to C#, but instead of using LINQ, Andrew chose to create a code generator that would allow him express SQL-style queries in C#. &nbsp;As a result, with a few exceptions, most of ObjectCloud's queries are expressed in pure C# and can be ported to other databases without significant effort.</p><p>Thus, the initial philosophies of ObjectCloud were:</p><p></p><ol><li>Be an operating system with an AJAX (in-browser Javascript) filesystem API, and have just enough smarts to serve HTML and Javascript "programs" that use the API.</li><li>Take advantage of C#'s operator overloading to avoid the&nbsp;impedance&nbsp;mismatch of writing most of ObjectCloud's queries in another language.</li><li>Avoid "dumb terminal" style web applications where the server performs all logic needed to render HTML.</li></ol><p></p><h2>Introduction of WebComponents</h2><p>The WebComponent system came about from systems that Walter Roth showed to Andrew prior to him starting WebDOS. &nbsp;Walter showed Andrew systems where a web page designer, with minimal knowledge of web technologies, could add a discussion to any web page by merely adding a simple &lt;script&gt; tag. &nbsp;Andrew liked the flexibility of allowing any page to pull any component from a 3rd party source; but quickly objected to obvious technical limitations. &nbsp;Assembling pages from many Javascript snippits served from many 3rd parties is quite fragile in the long term, as a page built from such components will break when the 3rd party either goes out of business or updates their API. &nbsp;Furthermore, using 3rd party Javascript for major&nbsp;functionality&nbsp;will yield poor performance or break in constrained situations; such as slower internet connections, secured private networks, limited hardware, and mobile.</p><p>Andrew decided to include a component system in WebDOS that could evolve to provide similar functionality to using the &lt;script&gt; tag without being fragile. &nbsp;He wanted something that could have a competing implementation on another platform, if needed. &nbsp;Andrew chose to implement a component system with syntax similar to PHP so that the component system could work with Apache and IIS in a similar manner to how COM is supported with Unixes, even though it's primarily a Windows technology. &nbsp;He chose to make WebComponents work in a manner similar to server-side includes, but with GET arguments. &nbsp;At its core, a WebComponent runs a sub request that includes GET arguments that is inserted into a page's results. &nbsp;The system also allows using WebComponents to include data that would normally require a&nbsp;separate&nbsp;AJAX request, thus potentially letting applications load faster.&nbsp;</p><p>At this time, the WebComponent system can only work with requests for the same server; although multiple servers could be supported in the future with the addition of caching. &nbsp;The caching is&nbsp;necessary&nbsp;in the event that a 3rd party WebComponent becomes unavailable. &nbsp;The syntax looks like PHP, so, in theory, a distributed WebComponent system could be ported to Apache and IIS.</p><h2>Javascript Library<br></h2><p>Operating Systems like Windows and Mac; and programming environments like Java and .Net, now provide ways for programs to manage their dependancies. &nbsp;This is useful as many of today's powerful programs are built on top of a wealth of powerful components and libraries; and these powerful components and libraries are often built upon other components and libraries. &nbsp;As a result, the complete program could have a dizzying group of dependancies.</p><p>A limitation of HTML's &lt;script&gt; tag is that it offers no support for assisting the page in loading&nbsp;dependent&nbsp;scripts; thus the page creator must know all the needed scripts to include, or (s)he must construct a single master script. &nbsp;To solve this issue; Andrew integrated a&nbsp;dependency&nbsp;walker into the WebComponent system. &nbsp;The&nbsp;dependency&nbsp;walker does the following:</p><p></p><ul><li>Ensures that a script used by multiple WebComponents is only included once in a complete page.</li><li>Inspects the top of every included script to see if it requires another script</li><li>Includes all&nbsp;dependent&nbsp;scripts.</li></ul><p></p><p>Thus, if a page used three WebComponents that all use the same script, only one &lt;script&gt; tag would be present. &nbsp;Likewise, if a WebComponent used a script that depends on other scripts, all needed &lt;script&gt; tags are generated. &nbsp;This allows for scripts to add dependancies without needing to change referencing pages and WebComponents.</p><p>ObjectCloud's Javascript library system also is designed with performance in mind. &nbsp;It appends an MD5 to the URL of each script, which instructs the server to include a flag that tells the browser to cache the script for a long time. &nbsp;This means that scripts are only downloaded from ObjectCloud the first time they are used, and whenever they change, thus allowing for pages to load much faster.</p><h2>Limitations of the Original Philosophy</h2><p>The limitations of the original design essentially have to do with security. &nbsp;Raw file APIs only offer minimal security; specifically, the initial security system was built around three levels of security; read, write, and administer. &nbsp;The problem with these levels of permissions, and "dumb" file APIs like a traditional operating system, is that anyone who has read access can see all data in the file, and anyone who has write access can make any possible change to the file.</p><p>The above situations are problematic in&nbsp;collaborative&nbsp;and social situations. &nbsp;Sometimes someone who has "read" permission to an object shouldn't be able to see all data in the object. &nbsp;Other times, someone who has "write" access to an object should only be able to make a limited set of well known modifications to the data. &nbsp;If all logic is performed in browser-side Javascript, then a malicious&nbsp;knowledgeable&nbsp;user could manipulate the data in undesired way. &nbsp;For example, a malicious user could record extra votes.</p><p><span class="Apple-style-span" style="font-size: 24px; font-weight: bold; ">Server-Side Objects</span></p><p>From the beginning, WebDOS manifested its file API by treating each file as an object; each file access function is a method on the "file" object. &nbsp;In addition, to aid the programmer, WebDOS started with a few different core file types: text file, name-value pairs, binary file, and a SQLite database. &nbsp;The different APIs shield the programmer from the tedium of dealing with rudimentary translation of data structures to persistance; likewise, these core data representations are used in different ways for configuring the system at runtime.</p><h2>Necessity&nbsp;of Server-Side Javascript for Data Access<br></h2><p>Andrew chose Javascript over other scripting languages to minimize ObjectCloud's development learning curve and avoid requiring mastering many languages; AND because Javascript lends itself to developing seamless RPC systems. &nbsp;This&nbsp;decision&nbsp;is somewhat painful as there are no good Javascript interpreters for .Net, thus requiring that Andrew use a trick to convert a Java Javascript interpreter into a .Net dll.<br></p><meta charset="utf-8"><p>Originally, server-side Javascript followed the object-oriented programming model. &nbsp;As implemented, a programmer could create Javascript "classes" that wrapped the lower-level file APIs. &nbsp;These Javascript "classes" explicitly declare the operations that different users can perform on the object; thus allowing more secure social use of a person's data. &nbsp;What's vital, when compared to other web frameworks, is that server-side Javascript is implemented in a self-describing way. &nbsp;A programmer can create server-side Javascript using the same techniques that another user would use to create files. &nbsp;In addition, new programs can use pre-existing data from old programs.</p><p>Another advantage of server-side Javascript for secure data access is that Javascript lends itself very well to serialization. &nbsp;This&nbsp;essentially&nbsp;allows ObjectCloud's Javascript file IO API to be extended to a seamless RPC system for in-browser Javascript to perform operations and requests on objects on the server. &nbsp;(The programmer can still construct an AJAX request, if needed.)&nbsp;&nbsp;Furthermore, the browser-side and server-side APIs are almost identical; the primary difference being that the&nbsp;asynchronous&nbsp;version of the API works better in the browser, and the syncronous version works better on the server.</p><p>Another advantage of choosing Javascript is that loosely-typed system allows for easier integration of Javascript and SQL. &nbsp;This means that classes that are built around SQLite database don't need to perform significant work in object/relational mapping.<br></p><meta charset="utf-8"><h1 style="font-size: 1.5em; font-weight: bold; ">Lessons From Comet</h1><p>A limitation of the HTTP protocol is that it's one-way. &nbsp;By design, the server only sends data to the browser when the browser asks for it. &nbsp;This makes it difficult for the programmer to make things appear on a user's screen as events happen on the server. &nbsp;The various techniques that enable a programmer to send data to the browser without it asking for it are collectively known as Comet.</p><p>Andrew investigated two different Comet protocols, but chose to write his own because the existing protocols either dictated too deeply the server's design; or were too complicated to implement. &nbsp;<a href="/Docs/Specs/Comet%20Protocol.page" title="" target="">Andrew's Comet specification, The Comet Protocol, discusses these tradeoffs</a>.</p><p>The lessons from implementing Comet in ObjectCloud were many:</p><p></p><ul><li>Existing web servers perform Comet poorly.</li><li>Many people active in Comet "forgot" about lessons from early TCP research. &nbsp;<a href="http://en.wikipedia.org/wiki/Nagle's_algorithm" title="" target="">Nagle's algorithm</a> is something that Comet programmers tend to re-invent.</li><li>Likewise, it's important that Comet implementations are "webby", Javascript-friendly, and impose light design constraints on the server.</li><ul><li>Event-subscription models are good design, but not all Comet fits into an event-subscription model.</li><li>Modeling everything as a wire protocol could result in poor performance and oversimplifies to the point of requiring the programmer to re-assemble packets that never needed to be broken up.</li></ul><li>Due to the low overhead of creating threads on modern computers, and difficulties in handling sockets, "non-blocking" web servers that handle multiple sockets per thread have little ROI for the extra effort; instead, the following approach yields the best ROI:</li><ul><li>Implement a pool of idle threads to pull from to handle incoming sockets</li><li>For Comet-style long-polling, don't block the thread until a result is returned to the browser. &nbsp;Instead, let the thread complete and return the result to the browser on a different thread.</li></ul><li>The standard HttpListener that comes with .Net and Mono has some bugs where the workarounds lead to incompatibilities between both implementations. &nbsp;It's better to use the same HTTP library in both .Net and Mono instead of working around differences in their implementations.</li></ul><p></p><h1>Lessons From Caching</h1><p>ObjectCloud relies on significant caching in order to improve performance.<br></p><h2>Client-Side Caching</h2><p>In addition to putting MD5s into URLs for Javascript libraries and then instructing the browser to cache these files for a long time; the HTTP protocol allows the browser to make requests where the server can instruct the browser to use a cached version of a result instead of the server transmitting the complete result. &nbsp;These kinds of requests can improve performance because the client doesn't need to wait for a result to be rendered and transmitted to the client. &nbsp;They introduce complexity in ObjectCloud because a request can pull data from many files; thus when handling caching; the server has to know what files will be hit and compare against all of their modified dates.</p><h2>Server-Side Caching</h2><p>A challenge in ObjectCloud is that many requests often have to look at many data sources and determine if the user has permission to access them. &nbsp;Due to physical limitations of data access, disk access becomes a significant performance bottleneck; even when serving relatively static files. &nbsp;As a result, static files have their contents cached in RAM until the server determines that it's&nbsp;necessary&nbsp;to unload the object. &nbsp;Likewise, the results of many queries, which are potentially disk intensive, but do not require much space, are also stored in RAM.</p><p>An initial mistake made was to rely on .Net's WeakReference system for caching, as WeakReferences allow memory to be reclaimed. &nbsp;It was discovered that WeakReferenced objects are collected more&nbsp;aggressively&nbsp;then anticipated, and that memory&nbsp;reclamation&nbsp;of WeakReferences is inherently non-deterministic due to the fact that .Net and Mono use different and continually improving garbage collection algorithms. &nbsp;As a result, Andrew implemented a&nbsp;varient of a first-in, first-out (FIFO) queue for its RAM cache. &nbsp;Each time a RAM&nbsp;cacheable&nbsp;object is accessed, if it is not in RAM, it is constructed and a handle is added to the queue. &nbsp;As ObjectCloud's memory usage increases, older handles are removed from the queue. &nbsp;When a RAM&nbsp;cacheable&nbsp;object has no handles in the queue, it is de-referenced and&nbsp;potentially&nbsp;made ready for garbage collection.</p><h1>Lessons From The Javascript AJAX API<br></h1><p>The Javascript AJAX API is automatically generated from the C# methods that ObjectCloud exposes to the web, and from server-side Javascript functions that are exposed to the web. &nbsp;Auto-generation was originally created to save time, as manually writing Javascript code to access these objects proved to be too labor intense.</p><p>The primary lesson from&nbsp;automatically&nbsp;creating the Javascript AJAX wrapper is that code generators can be great labor savers, as long as their scope is limited and doesn't pass through too many layers. &nbsp;Likewise, code generators as labor savers can only save labor if written early enough in a project's development timeframe.</p><p>A mistake in the Javascript AJAX wrapper is that it imposed an order to the arguments. &nbsp;Andrew made this mistake because he was more familiar with C# and Java conventions. &nbsp;This quickly made it difficult to update server-side methods, as changing the order of arguments, or even adding arguments, would break existing Javascript without compilation errors. &nbsp;Refactoring to encapsulate arguments as a single JSON object was somewhat expensive; although it greatly improved the the API.</p><p>Another mistake is that there were too many differences between the generated code for the server-side and browser-side API, and that the browser-side API relied on the Prototype framework. &nbsp;As a result, the differences between the browser-side API and server-side API created too much complexity in the code generator. &nbsp;The generated code's dependance on the Prototype framework meant that all Javascript had to live with changes that Prototype makes to the Javascript environment, including incompatibilities with JQuery.&nbsp;&nbsp;These problems were rectified when the Javascript API was updated by writing a simple AJAX wrapper with a well-defined interface, and then coding the generator against the AJAX wrapper. &nbsp;On the server-side, the AJAX wrapper interface is emulated so that the same Javascript AJAX wrapper can be used.</p><p>The similarities between server-side and browser-side Javascript will come in handy as more browsers support multithreaded Javascript, because code written against the blocking version of the API will be able to run on both the client and server.</p><h1>Lessons From the WebComponent System</h1><p>The WebComponent system, with the philosophy that applications would be written to run in the browser, put too much rendering logic into the client. &nbsp;This is problematic in mobile and other constrained situations where significant client rendering imposes a performance penalty; or where sending unneeded data slows down loading. &nbsp;Furthermore, sometimes behavior needs to be conditional based on headers that the browser sends, or other conditions that are best read on the server. &nbsp;This is the case when ObjectCloud instructs IE users to install ChromeFrame.</p><p>As a result, the server-side Javascript system was extended to allow for using Javascript for server-side rendering of .ssjs files. &nbsp;This creates a lightweight way of performing logic on the server while rendering HTML, and it also can be extended as a user-visible way to script tasks; as the complete server management API is present. &nbsp;.ssjs files are based around ObjectCloud's design goal of being self-describing; they are stored with user data and created using the same APIs for user data. &nbsp;All code for interpreting .ssjs files is implemented in server-side Javascript itself.</p><h1>Overall Lessons and Final Direction</h1><p>The final lesson from developing ObjectCloud is that the concepts of filenames and directories end up being burdensome for both the user and programmer. &nbsp;Per ObjectCloud's design, the user is burdened with an ever-growing mountain of files that must be manually created and named. &nbsp;This often gets in the way, as a file must be placed in an appropriate location, named, and then later hyperlinks must be added by copying and pasting URLs. &nbsp;This also becomes burdensome for the programmer as the he or she must figure out an appropriate place to put a file and infer or request a name. &nbsp;It is also difficult to maintain relationships among files, as sometimes relationships are significantly more complicated then merely grouping files into&nbsp;hierarchal&nbsp;directories. &nbsp;This lead Andrew to experiment with systems that allow the programmer to declare&nbsp;arbitrary&nbsp;relationships among files, but the files must be in the same folder in order for the system to work.</p><p>Folders and directories were chosen as it naturally matches how many of us are used to working with web servers; both Apache and IIS present folders and directories that a user can navigate if there isn't an index.html file. &nbsp;This organization strategy was simple to implement in WebDOS and it didn't require the research, development, and&nbsp;experimentation&nbsp;required when creating a new navigation paradigm.</p><p>The <a href="http://cs-www.cs.yale.edu/homes/freeman/lifestreams.html" title="" target="">Lifestream</a> concept,&nbsp;<span class="Apple-style-span" style="font-size: medium; ">invented by&nbsp;<a href="http://www.cs.yale.edu/homes/freeman-eric.html">Eric Freeman</a>&nbsp;and&nbsp;<a href="http://www.cs.yale.edu/people/faculty/gelernter.html">David Gelernter</a>, is a natural fit for ObjectCloud. &nbsp;Their experiment was based around a server that holds all of a person's documents and is&nbsp;accessible&nbsp;from many devices. &nbsp;The clients provide navigation to a user's documents in a time, query, and search based view. &nbsp;Users never create file names or folders; instead, they file older files by navigating through time and search. &nbsp;Future versions of ObjectCloud may borrow from this work as an attempt to move away from the burden of maintaining file names and folders.</span></p>