{"Title":"History and Direction of ObjectCloud","Contents":"\n<p>ObjectCloud arose out of discussions between Andrew Rondeau and Walter Roth in early 2008. Its original goal was to build a web-based system capable of replacing a desktop computer, and is based on the following principles:</p><div><ol><li><b>Privacy and openness is important:&#160;</b>A vocal minority of users will need to host their own data.</li><li><b>True innovation requires comfort working \"close to the metal\":&#160;</b>In order to experiment with different APIs, one needs to be comfortable working with HTTP at the socket level.</li><li><b>3rd Party Services are inherently unreliable</b>: The core of a computing environment must be self-contained so it can exist for a long time as the internet evolves.</li><li><b>A complete reference implementation is vital for adoption</b>: A complete reference&#160;implementation&#160;is needed for experimentation, and thus adoption.</li></ol><h1>Inspiration</h1></div><p>ObjectCloud&#160;grew out of an idea that Andrew had called WebDOS, which would be a central web-accessible analogous to a user's Documents folder on a desktop computer. This idea was re-incarnated in early 2008 when Walter showed Andrew a product named Spoxel. At the time, Andrew realized that web-based operating systems need to be self-describing, much like how Windows, MacOS, and Linux store most of their program data within the user-visible file system.</p><p>The idea for WebDOS was to create a web server that acted like a desktop operating system. Most of the operating system would rely on a Javascript API based around REST and would be stored on the web server itself. Like how complete desktop applications can be written based on user-available APIs, WebDOS would allow powerful applications without server-side programming.</p><p>Walter and Andrew's discussions centered around AppFeeds, Walter's idea for a business around social computing. Directly&#160;influential&#160;to ObjectCloud were needs for&#160;a distributed authentication system, data portability, the freedom to let customers choose their own hosting situation, if desired, and the merits and constraints of different web technologies.</p><p>The name WebDOS was later replaced with ObjectCloud.</p><h1>Initial Philosophy and Design Constraints</h1><p>When starting ObjectCloud, the initial design&#160;philosophy was to build web applications using the same design approach that one uses when building a desktop application. &#160;The web server would be designed just like an operating system, provide a file I/O API in Javascript through AJAX, and enforce user permissions for security. &#160;It would contain files and directories that map directly with the URL; that is, \"http://myserver.com/myfolder\" would be a user-manipulatable folder. &#160;Theoretically, the core of the server would only be smart enough to serve just enough HTML, Javascript, and images so that the application would load in the browser and handle all needed logic.</p><p>Andrew started programming ObjectCloud in Java, but quickly grew frustrated with its inability to provide a clean query syntax. As a result, Andrew moved to C# and implemented a technique for expressing SQL-like expressions in C#.</p><p></p><h2>Components</h2><p>Early versions of ObjectCloud heavily relied on a \"WebComponent\" system that behaved in a similar manner to server-side includes. &#160;It was inspired when&#160;Walter showed Andrew systems where a web page designer, with minimal knowledge of web technologies, could add a discussion to any web page by merely adding a simple &lt;script&gt; tag that referenced a 3rd party library. &#160;Andrew liked the flexibility of allowing any page to pull any component from a 3rd party source; but found the approach fragile.</p><p>The WebComponent system was later replaced with an XML-based templating system that supports server-side components. &#160;This allows a developer to install services on the ObjectCloud server, which are fundamentally more reliable then 3rd party Javascript services.</p><h2>Javascript Library<br/></h2><p>Operating Systems like Windows and Mac; and programming environments like Java and .Net, now provide ways for programs to manage their dependancies. &#160;This is useful as many of today's powerful programs are built on top of a wealth of powerful components and libraries; and these powerful components and libraries are often built upon other components and libraries. &#160;As a result, the complete program could have a dizzying group of dependancies.</p><p>ObjectCloud comes with a set of popular Javascript libraries in <a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"/API\">/API</a>.</p><p>Andrew applied the \"like an operating system\" philosophy by including powerful Javascript libraries in&#160;<a xmlns=\"http://www.w3.org/1999/xhtml\" href=\"http://10.0.1.198:1080/API\">/API</a>, and by providing&#160;dependency&#160;trackers. &#160;This means that&#160;individual&#160;scripts can declare their dependancies, and when pages use a single script, the page author can be assured that all&#160;dependent&#160;scripts are loaded.</p><p>ObjectCloud's Javascript library system also is designed with performance in mind. &#160;When using the templating system, Javascript is automatically merged into a single file, minimized, and cached in the browser. &#160;This dramatically improves loading time while one uses ObjectCloud.</p><h2>Limitations of the Original Philosophy</h2><p>The limitations of the original design essentially have to do with security and performance.</p><p>Raw file APIs with just Read, Write, and Administer permission levels allow anyone with \"Read\" access to see all data in a file, and anyone with \"Write\" access to make any change possible. Furthermore, relying purely on RESTful APIs without server-side programming will result in too many calls between the browser and server, thus being problematic on slow and unreliable connections.</p><p>These issues are addressed with named permissions and server-side Javascript. &#160;Users can be given permission to perform a specified action on a file. Server-side Javascript has access to the same RESTful API that the browser has access to, and can access special elevated security contexts. As a result, server-side Javascript can be used make multiple calls in succession on a single HTTP request, and can access data that a user can not manipulate through REST.</p><p></p><h1 style=\"font-size: 1.5em; font-weight: bold; \">Real-Time (Comet)</h1><p>A limitation of the HTTP protocol is that it's one-way. By design, the server only sends data to the browser when the browser asks for it. This makes it difficult for the programmer to make things appear on a user's screen as events happen on the server. The various techniques that enable a programmer to send data to the browser without it asking for it are collectively known as Comet.</p><p>Andrew investigated two different Comet protocols, but chose to write his own because the existing protocols either dictated too deeply the server's design; or were too complicated to implement.&#160;<a href=\"/Docs/Specs/Comet%20Protocol.page\" title=\"\" target=\"\">Andrew's Comet specification, The Comet Protocol, discusses these tradeoffs</a>.</p><p>ObjectCloud's Comet protocol is based on long-polling. It has a multiplexer that allows a single page to listen to many different services on the same server without holding too many sockets open. Different forms of Comet are allowed, including a reliable TCP-style version that includes&#160;<a href=\"http://en.wikipedia.org/wiki/Nagle's_algorithm\" title=\"\" target=\"\">Nagle's algorithm</a>, and a UDP unreliable event-loop format.</p><h1>Notification System</h1><p>The notification system was originally designed to address implementation flaws seen in a popular open-source product that allowed concurrent editing of documents. Andrew quickly grew frustrated with this product because, although it claimed that it was open source, no viable reference implementation was released on the market. Thus, it was impossible for the general community to have true experimental servers.</p><p>The core of the notification system later evolved into a protocol designed for open social networking. It isn't tied to any specific data format, and instead exchanges URLs. This allows anyone to share anything that has a URL, yet keeps implementations simple.</p>"}